<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Gambler's Dilemma: One Big Bet vs Many Small Bets</title>
  <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    /* ===== Enhanced Color Palette ===== */
    :root {
      --primary-red: #FF1A4D;
      --primary-purple: #6C1AFF;
      --dark-bg: #0A0E27;
      --content-bg: #1A1F3A;
      --accent-purple: #9D4DFF;
      --accent-red: #FF4D88;
      --ink: #F8F1FF;
      --muted: #B8B3C8;
      --success: #4ADE80;
      --warning: #FCD34D;
      --border: rgba(157, 77, 255, 0.3);
      --glass: rgba(255, 255, 255, 0.05);
    }

    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(135deg, #0A0E27 0%, #1A0A29 50%, #2D0A3D 100%);
      color: var(--ink);
      font: 16px/1.6 'Inter', system-ui, -apple-system, sans-serif;
      scroll-behavior: smooth;
    }

    /* ===== Typography ===== */
    h1, h2, h3 {
      font-family: 'Russo One', system-ui, sans-serif;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    h1 {
      font-size: clamp(28px, 4vw, 48px);
      margin: 20px 0;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-red));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
    }

    h2 {
      font-size: 22px;
      margin: 20px 0 12px;
      color: var(--accent-purple);
    }

    h3 {
      font-size: 18px;
      margin: 16px 0 8px;
      color: var(--muted);
    }

    p {
      margin: 12px 0;
      color: var(--muted);
      line-height: 1.7;
    }

    a {
      color: var(--accent-red);
      text-decoration: none;
      transition: opacity 0.2s;
    }

    a:hover {
      opacity: 0.8;
    }

    /* ===== Layout ===== */
    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .hero {
      text-align: center;
      padding: 40px 20px;
      margin-bottom: 40px;
      background: var(--glass);
      border-radius: 24px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
    }

    .story {
      max-width: 800px;
      margin: 0 auto 40px;
      padding: 30px;
      background: var(--glass);
      border-radius: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
    }

    .story-highlight {
      padding: 20px;
      margin: 20px 0;
      background: linear-gradient(135deg, rgba(108, 26, 255, 0.1), rgba(255, 26, 77, 0.05));
      border-left: 4px solid var(--accent-purple);
      border-radius: 8px;
    }

    .grid {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
    }

    @media (max-width: 1100px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, rgba(108, 26, 255, 0.08), rgba(108, 26, 255, 0.02));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
    }

    /* ===== Controls ===== */
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      padding: 28px;
      margin-bottom: 30px;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    input[type="number"], select {
      background: var(--glass);
      border: 1px solid var(--border);
      color: var(--ink);
      padding: 12px;
      border-radius: 12px;
      outline: none;
      font-size: 14px;
      transition: all 0.2s;
    }

    input[type="number"]:focus, select:focus {
      border-color: var(--accent-purple);
      box-shadow: 0 0 0 3px rgba(157, 77, 255, 0.1);
    }

    input[type="range"] {
      width: 100%;
      margin-top: 8px;
    }

    .btn {
      background: linear-gradient(135deg, var(--primary-red), var(--primary-purple));
      color: white;
      border: 0;
      border-radius: 14px;
      padding: 14px 24px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 24px rgba(255, 26, 77, 0.3);
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 13px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(255, 26, 77, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.ghost {
      background: transparent;
      border: 2px solid var(--border);
      box-shadow: none;
    }

    .btn.ghost:hover {
      border-color: var(--accent-purple);
      box-shadow: 0 0 20px rgba(157, 77, 255, 0.3);
    }

    /* ===== Metrics & Indicators ===== */
    .meter {
      height: 28px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 14px;
      border: 1px solid var(--border);
      overflow: hidden;
      margin: 12px 0;
      position: relative;
    }

    .meter::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .fill {
      height: 100%;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .fill.good {
      background: linear-gradient(90deg, var(--primary-purple), var(--accent-purple));
    }

    .fill.bad {
      background: linear-gradient(90deg, var(--primary-red), #FF7B8A);
    }

    .kpi {
      display: flex;
      align-items: baseline;
      gap: 12px;
      margin: 16px 0;
    }

    .kpi .val {
      font-weight: 800;
      font-size: 36px;
      font-variant-numeric: tabular-nums;
      background: linear-gradient(135deg, var(--ink), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .kpi .sub {
      opacity: 0.7;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* ===== Tags & Pills ===== */
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 16px 0;
    }

    .tag {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px dashed var(--border);
      color: var(--muted);
      font-size: 12px;
      font-family: 'Courier New', monospace;
      background: var(--glass);
    }

    .pill {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      background: var(--glass);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pill.success {
      border-color: var(--success);
      color: var(--success);
      background: rgba(74, 222, 128, 0.1);
    }

    .pill.danger {
      border-color: var(--primary-red);
      color: var(--primary-red);
      background: rgba(255, 26, 77, 0.1);
    }

    /* ===== Wheel Animation ===== */
    .wheelWrap {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 24px;
      align-items: center;
      padding: 20px;
      background: var(--glass);
      border-radius: 16px;
      margin: 20px 0;
    }

    .wheel {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: conic-gradient(
        var(--primary-red) 0 47.37%,
        #1A1F3A 47.37% 50%,
        var(--primary-purple) 50% 97.37%,
        #1A1F3A 97.37% 100%
      );
      border: 8px solid var(--border);
      position: relative;
      box-shadow: 
        inset 0 0 40px rgba(0, 0, 0, 0.6),
        0 0 40px rgba(157, 77, 255, 0.3);
    }

    .peg {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-bottom: 18px solid var(--accent-red);
      filter: drop-shadow(0 0 8px rgba(255, 77, 136, 0.8));
    }

    .needle {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .needle > div {
      width: 3px;
      height: 70%;
      background: linear-gradient(to bottom, var(--accent-red), transparent);
      box-shadow: 0 0 10px var(--accent-red);
    }

    /* ===== Charts ===== */
    canvas {
      display: block;
      width: 100%;
      height: 320px;
      background: linear-gradient(180deg, rgba(157, 77, 255, 0.03), rgba(255, 26, 77, 0.02));
      border-radius: 16px;
      border: 1px solid var(--border);
      margin: 20px 0;
    }

    .viz {
      margin: 20px 0;
    }

    .legend {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin: 16px 0;
      padding: 12px;
      background: var(--glass);
      border-radius: 12px;
    }

    .swatch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .dot {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      background: var(--accent-purple);
      border: 1px solid var(--border);
    }

    .dot.good { background: var(--primary-purple); }
    .dot.bad { background: var(--primary-red); }

    /* ===== Interactive Elements ===== */
    .inline {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin: 20px 0;
    }

    .caption {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
      margin: 12px 0;
    }

    .footer {
      margin-top: 40px;
      padding: 30px;
      background: var(--glass);
      border-radius: 20px;
      border: 1px solid var(--border);
      text-align: center;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.8;
    }

    .mono {
      font-family: 'Courier New', monospace;
      background: var(--glass);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.95em;
    }

    /* ===== Responsive Design ===== */
    @media (max-width: 768px) {
      .controls { grid-template-columns: 1fr; }
      .wheelWrap { grid-template-columns: 1fr; text-align: center; }
      .wheel { margin: 0 auto; }
      h1 { font-size: 28px; }
      .kpi .val { font-size: 28px; }
    }

    /* ===== Animations ===== */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .loading {
      animation: pulse 1.5s infinite;
    }

    /* ===== Back Button ===== */
    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: var(--glass);
      color: var(--ink);
      padding: 12px 24px;
      border-radius: 12px;
      text-decoration: none;
      margin-bottom: 30px;
      transition: all 0.3s;
      font-weight: 600;
      border: 1px solid var(--border);
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateX(-5px);
      border-color: var(--accent-purple);
    }
  </style>
</head>
<body>
<div class="app">
  <a href="../mathematical-simulations" class="back-button">
    <span>←</span>
    <span>Back to Mathematical Simulations</span>
  </a>

  <div class="hero">
    <h1>The Gambler's Dilemma</h1>
    <p style="font-size: 18px; color: var(--ink); margin: 20px auto; max-width: 800px;">
      🎰 A Journey to the Roulette Table: One Big Bet vs Many Small Bets
    </p>
  </div>

  <div class="story">
    <h2>🎲 Welcome to the Casino Floor</h2>
    <p>
      Picture this: You walk into a casino with <strong>$10,000 in your pocket</strong>. The lights are flashing, the roulette wheels are spinning, 
      and you have a simple goal: <strong>walk out with $10,100</strong> — just $100 more than you came in with.
    </p>
    
    <p style="margin: 20px 0; padding: 20px; background: rgba(255, 77, 136, 0.1); border-radius: 12px; border-left: 4px solid var(--accent-red);">
      🎯 <strong>Your Mission:</strong> Turn $10,000 into $10,100<br>
      💰 <strong>Your Limit:</strong> You can't lose your entire $10,000<br>
      🎰 <strong>The Game:</strong> Roulette — betting on red or black
    </p>

    <div class="story-highlight">
      <h3>🤔 The Big Decision</h3>
      <p style="font-size: 18px; line-height: 1.8;">
        You have two strategies to choose from:
      </p>
      <p style="margin: 20px 0;">
        <strong>🎰 Strategy 1: The Bold Gambler</strong><br>
        Walk up to the table, place <strong>one single $100 bet</strong> on red. Win or lose, you're done in 10 seconds. 
        Your heart races for one moment, and then it's over.
      </p>
      <p>
        <strong>🎲 Strategy 2: The Patient Player</strong><br>
        Sit down and play for hours, making <strong>$1 bets</strong>. You need to win 100 more times than you lose. 
        It's a marathon, not a sprint.
      </p>
    </div>

    <h3>🎡 Understanding Roulette</h3>
    <p>
      Let's talk about the roulette wheel. In <strong>American roulette</strong>, there are:
    </p>
    <ul style="margin: 15px 0; padding-left: 30px; line-height: 1.8;">
      <li>18 red numbers 🔴</li>
      <li>18 black numbers ⚫</li>
      <li>2 green numbers (0 and 00) 🟢 — <em>this is the house edge!</em></li>
    </ul>
    <p>
      When you bet on red, you have 18 ways to win out of 38 total possibilities. That's <strong>47.37%</strong> — just under half!
      Those two green numbers? That's how the casino makes money. It's a tiny edge, but it adds up...
    </p>

    <div class="story-highlight" style="background: linear-gradient(135deg, rgba(108, 26, 255, 0.15), rgba(255, 26, 77, 0.08));">
      <h3>💡 The Key Insight</h3>
      <p style="font-size: 17px; line-height: 1.8;">
        Here's what most people don't realize: <strong>The house edge is like interest, but in reverse.</strong>
      </p>
      <p>
        • With <strong>one bet</strong>, the house edge hits you once<br>
        • With <strong>100 bets</strong>, it compounds 100 times<br>
        • With <strong>10,000 bets</strong>, you're almost guaranteed to lose
      </p>
      <p style="margin-top: 16px; font-style: italic;">
        "The casino doesn't gamble. They just let math do the work."
      </p>
    </div>
  </div>

  <!-- Step-by-Step Tutorial Section -->
  <div class="story" style="margin-bottom: 30px;">
    <h2>🎓 Quick Interactive Tutorial</h2>
    <p style="font-size: 16px; line-height: 1.7;">
      Let's walk through a simple example to see why one big bet beats many small bets:
    </p>
    
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin: 30px 0;">
      <!-- Step 1 -->
      <div style="padding: 20px; background: linear-gradient(135deg, rgba(108, 26, 255, 0.1), rgba(108, 26, 255, 0.05)); border-radius: 12px; border: 1px solid var(--border);">
        <h3 style="color: var(--accent-purple); margin-bottom: 10px;">Step 1: One Big Bet</h3>
        <p style="font-size: 20px; font-weight: bold; margin: 10px 0;">🎲 → Win or Lose</p>
        <p style="font-size: 14px;">You bet once. 47.37% chance to win. It's almost a coin flip!</p>
        <p style="margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; font-size: 13px;">
          <strong>Think of it like:</strong> Flipping one slightly unfair coin.
        </p>
      </div>
      
      <!-- Step 2 -->
      <div style="padding: 20px; background: linear-gradient(135deg, rgba(255, 77, 136, 0.1), rgba(255, 77, 136, 0.05)); border-radius: 12px; border: 1px solid var(--border);">
        <h3 style="color: var(--accent-red); margin-bottom: 10px;">Step 2: 100 Small Bets</h3>
        <p style="font-size: 20px; font-weight: bold; margin: 10px 0;">🎲🎲🎲...🎲</p>
        <p style="font-size: 14px;">You need to win MORE than you lose across 100+ bets. Much harder!</p>
        <p style="margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; font-size: 13px;">
          <strong>Think of it like:</strong> Flipping 100 unfair coins and hoping for more heads than tails.
        </p>
      </div>
      
      <!-- Step 3 -->
      <div style="padding: 20px; background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(74, 222, 128, 0.05)); border-radius: 12px; border: 1px solid rgba(74, 222, 128, 0.3);">
        <h3 style="color: #4ADE80; margin-bottom: 10px;">Step 3: The Result</h3>
        <p style="font-size: 20px; font-weight: bold; margin: 10px 0;">📊 47% vs ~5%</p>
        <p style="font-size: 14px;">One bet: 47% chance. Many bets: Often less than 5% chance!</p>
        <p style="margin-top: 10px; padding: 10px; background: rgba(255, 255, 255, 0.05); border-radius: 8px; font-size: 13px;">
          <strong>The lesson:</strong> When odds are against you, minimize exposure!
        </p>
      </div>
    </div>
    
    <div style="text-align: center; margin-top: 20px;">
      <p style="font-size: 16px; color: var(--accent-purple); font-weight: 600;">
        Ready to see it in action? Use the controls below! 👇
      </p>
    </div>
  </div>

  <div class="card controls">
    <h2>🎮 Configure Your Casino Visit</h2>
    
    <div style="padding: 15px; background: rgba(255, 207, 77, 0.1); border-radius: 12px; margin-bottom: 20px; border-left: 4px solid var(--warning);">
      <p style="margin: 0; font-size: 14px; line-height: 1.6;">
        💡 <strong>Quick Start:</strong> Leave everything as-is to simulate a typical American roulette scenario where you're trying to win $100!
      </p>
    </div>

    <label>🎡 Choose Your Roulette Wheel
      <select id="preset">
        <option value="american">🇺🇸 American Roulette (38 numbers - worse odds)</option>
        <option value="european">🇪🇺 European Roulette (37 numbers - better odds)</option>
        <option value="custom">🔧 Custom Probability</option>
      </select>
    </label>
    <label>Your Chance of Winning Each Bet
      <input id="p" type="number" step="0.0001" min="0" max="1" value="0.4737" />
      <span style="font-size: 12px; color: var(--muted); font-weight: normal;">18/38 = 47.37% for American roulette</span>
    </label>
    <label>🎯 How Much Do You Want to Win?
      <input id="target" type="number" step="1" min="1" value="100" />
      <span style="font-size: 12px; color: var(--muted); font-weight: normal;">Your profit goal in dollars</span>
    </label>
    <label>💰 How Much Can You Afford to Lose?
      <input id="loss" type="number" step="1" min="1" value="10000" />
      <span style="font-size: 12px; color: var(--muted); font-weight: normal;">Your maximum loss limit</span>
    </label>
    <label>🎲 Size of Each Small Bet
      <input id="unit" type="number" step="1" min="1" value="1" />
      <span style="font-size: 12px; color: var(--muted); font-weight: normal;">For the "many bets" strategy</span>
    </label>
    <label>🌭 Betting Strategy
      <select id="strategy">
        <option value="unit">🛡️ Safe: Fixed $1 bets</option>
        <option value="martingale">⚠️ Risky: Double after each loss (Martingale)</option>
      </select>
    </label>
    <label>🔬 Simulation Accuracy
      <input id="paths" type="number" step="100" min="100" value="5000" />
      <span style="font-size: 12px; color: var(--muted); font-weight: normal;">More paths = more accurate (but slower)</span>
    </label>
    <button id="run" class="btn">🎰 Run Simulation</button>
  </div>

  <div class="grid">
    <div class="card">
      <h2>🎰 Strategy One: The Bold Gambler</h2>
      <p class="caption" style="font-size: 16px; line-height: 1.7; margin-bottom: 20px;">
        <strong>One bet. One spin. One moment.</strong> You place $100 on red and hold your breath. 
        The wheel spins, the ball bounces... and in 10 seconds, you either walk away a winner or a loser.
      </p>
      <div style="padding: 15px; background: rgba(157, 77, 255, 0.1); border-radius: 12px; margin-bottom: 20px;">
        <p style="margin: 0; font-size: 14px; line-height: 1.6;">
          🎯 <strong>Why this might work:</strong> The house only gets one chance to use their edge against you. 
          It's like crossing a minefield — better to run straight across than to zigzag for hours!
        </p>
      </div>
      <div class="wheelWrap">
        <div class="wheel" id="wheel">
          <div class="peg"></div>
          <div class="needle"><div></div></div>
        </div>
        <div>
          <div class="kpi">
            <span class="val" id="bigProb">–%</span>
            <span class="sub">Success Probability</span>
          </div>
          <div class="meter">
            <div class="fill good" id="bigBar" style="width:0%"></div>
          </div>
          <div class="row">
            <span class="pill" style="background: rgba(108, 26, 255, 0.2); color: var(--accent-purple);">🎰 One Spin</span>
            <span class="pill" style="background: rgba(255, 26, 77, 0.2); color: var(--accent-red);">🔴 18/38 chance</span>
          </div>
          <div class="inline">
            <button class="btn ghost" id="spinOnce">Spin the Wheel</button>
            <span class="pill" id="bigOutcome">Ready</span>
          </div>
        </div>
      </div>
      <canvas id="wheelChart"></canvas>
    </div>

    <div class="card">
      <h2>🎲 Strategy Two: The Patient Player</h2>
      <p class="caption" style="font-size: 16px; line-height: 1.7; margin-bottom: 20px;">
        <strong>The slow and steady approach.</strong> You sit down with $10,000 and make $1 bets. 
        Win by win, loss by loss, you inch toward your goal. But every spin is another chance for the house edge to work against you.
      </p>
      <div style="padding: 15px; background: rgba(255, 77, 136, 0.1); border-radius: 12px; margin-bottom: 20px;">
        <p style="margin: 0; font-size: 14px; line-height: 1.6;">
          ⚠️ <strong>The hidden danger:</strong> Each bet is like a tiny leak in your boat. 
          One leak? No problem. But thousands of leaks? You're going to sink!
        </p>
      </div>
      <div class="kpi">
        <span class="val" id="ruinProb">–%</span>
        <span class="sub">Success Probability</span>
      </div>
      <div class="meter">
        <div class="fill good" id="ruinBar" style="width:0%"></div>
      </div>
      <div style="padding: 15px; background: rgba(157, 77, 255, 0.05); border-radius: 12px; margin: 20px 0;">
        <p style="margin: 0; font-size: 14px; line-height: 1.6;" id="analyticNote">
          📊 <strong>What's happening:</strong> Each bet is like a step on a tightrope. You're trying to reach the other side (your profit goal) 
          without falling (hitting your loss limit). The more steps you take, the more likely you are to fall!
        </p>
      </div>
      <div class="viz">
        <canvas id="pathsChart"></canvas>
        <div class="legend">
          <span class="swatch"><span class="dot good"></span> Sample Paths</span>
          <span class="swatch"><span class="dot"></span> Target Goal</span>
          <span class="swatch"><span class="dot bad"></span> Ruin Threshold</span>
        </div>
      </div>
      <div class="inline">
        <button class="btn" id="play">Start Journey</button>
        <button class="btn ghost" id="pause">Pause</button>
        <button class="btn ghost" id="step">Single Step</button>
        <label style="flex: 1; min-width: 200px;">Simulation Speed
          <input id="speed" type="range" min="1" max="60" value="30" />
        </label>
        <span class="pill" id="liveStatus">Ready</span>
      </div>
    </div>
  </div>

  <div class="grid" style="margin-top: 20px;">
    <div class="card">
      <h2>⏱️ How Long Does It Take?</h2>
      <p class="caption" style="font-size: 15px; line-height: 1.6;">
        This shows how many spins it typically takes to either win or lose. 
        Notice how the "many bets" strategy can take thousands of spins!
      </p>
      <canvas id="histChart"></canvas>
    </div>
    <div class="card">
      <h2>📉 The Compound Effect</h2>
      <p class="caption" style="font-size: 15px; line-height: 1.6;">
        This graph shows the most important insight in gambling: <strong>the more you play, the more certain your loss becomes.</strong>
        The house edge compounds over time like reverse interest!
      </p>
      <canvas id="compareChart"></canvas>
      <div style="padding: 12px; background: rgba(255, 207, 77, 0.1); border-radius: 8px; margin-top: 15px;">
        <p style="margin: 0; font-size: 13px; line-height: 1.5;">
          🔍 <strong>What this shows:</strong> Starting with a 47.4% win rate (American roulette), your chances of being ahead after:
          • <strong>1 bet:</strong> 47.4% (almost fair!)
          • <strong>100 bets:</strong> ~25% (getting worse)
          • <strong>1,000 bets:</strong> ~5% (entering danger zone)
          • <strong>10,000 bets:</strong> Nearly 0% (almost guaranteed loss)
        </p>
        <p style="margin: 8px 0 0 0; font-size: 13px; line-height: 1.5; font-style: italic;">
          💡 The red "danger zone" shows when your odds drop below 10%. Notice how quickly you enter this zone as the number of bets increases!
        </p>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top: 20px;">
    <h2>🧪 Is This Simulation Accurate?</h2>
    <p class="caption" style="font-size: 15px; line-height: 1.6;">
      Good question! We can verify our simulation against proven mathematical formulas. 
      This ensures we're giving you accurate probabilities, not just random numbers.
    </p>
    <div class="inline">
      <button class="btn" id="selfTest">✅ Verify Accuracy</button>
      <span class="pill" id="selfNote">Not verified</span>
    </div>
    <div class="row" style="margin-top: 20px;">
      <span class="tag">🎯 Test 1: 50/50 odds check</span>
      <span class="tag">📊 Test 2: Math formula comparison</span>
      <span class="tag">🔍 Test 3: Edge case handling</span>
    </div>
  </div>

  <div class="story" style="margin-top: 40px;">
    <h2>📊 What Did We Learn?</h2>
    
    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 30px 0;">
      <div style="padding: 20px; background: rgba(108, 26, 255, 0.1); border-radius: 12px; border: 1px solid var(--border);">
        <h3 style="color: var(--accent-purple); margin-bottom: 10px;">🎰 One Big Bet</h3>
        <p style="font-size: 24px; font-weight: bold; margin: 10px 0;">47.37%</p>
        <p style="font-size: 14px;">Your exact odds of winning. Almost a coin flip!</p>
      </div>
      
      <div style="padding: 20px; background: rgba(255, 26, 77, 0.1); border-radius: 12px; border: 1px solid var(--border);">
        <h3 style="color: var(--accent-red); margin-bottom: 10px;">🎲 Many Small Bets</h3>
        <p style="font-size: 24px; font-weight: bold; margin: 10px 0;">Much Lower!</p>
        <p style="font-size: 14px;">The more you play, the more certain your loss becomes.</p>
      </div>
    </div>

    <h3>🧠 The Intuitive Explanation</h3>
    <p style="font-size: 16px; line-height: 1.8;">
      Think of it like this: Imagine you're flipping a slightly unfair coin that lands on heads 47.37% of the time instead of 50%.
    </p>
    
    <ul style="margin: 20px 0; padding-left: 30px; line-height: 2;">
      <li><strong>Flip it once:</strong> You have a 47.37% chance of heads — pretty close to fair!</li>
      <li><strong>Flip it 10 times:</strong> Getting more heads than tails becomes harder</li>
      <li><strong>Flip it 1,000 times:</strong> The 2.63% disadvantage adds up significantly</li>
      <li><strong>Flip it 10,000 times:</strong> You're almost certain to have more tails than heads</li>
    </ul>

    <div class="story-highlight" style="background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(74, 222, 128, 0.05));">
      <h3>✅ The Bottom Line</h3>
      <p style="font-size: 17px; line-height: 1.8; margin: 15px 0;">
        <strong>If you must gamble with a disadvantage, do it quickly!</strong>
      </p>
      <p>
        The math is clear: When the odds are against you, your best chance is to minimize the number of times 
        you let those odds work against you. It's counterintuitive, but <strong>being bold is actually the conservative strategy</strong> 
        when facing a house edge.
      </p>
    </div>

    <h3>🎯 Real-World Application</h3>
    <p>
      This principle extends beyond gambling:
    </p>
    <ul style="margin: 20px 0; padding-left: 30px; line-height: 2;">
      <li>📈 <strong>Investing:</strong> High-frequency trading with transaction costs</li>
      <li>🎮 <strong>Gaming:</strong> Repeated plays of unfavorable lottery games</li>
      <li>💼 <strong>Business:</strong> Taking many small risks vs. one calculated risk</li>
      <li>⚽ <strong>Sports:</strong> Defending a lead vs. pushing for more goals</li>
    </ul>
  </div>

  <div class="footer">
    <h3>📚 The History & Math</h3>
    <p>
      This problem, known as the <strong>Gambler's Ruin</strong>, was first studied by Blaise Pascal and Pierre de Fermat in 1656.
      They were trying to solve a problem about dividing stakes in an interrupted game, and ended up founding probability theory!
    </p>
    <p style="margin-top: 16px;">
      <strong>Fun Fact:</strong> The exact same math that describes your roulette odds also describes:
      • Random walks of molecules (Brownian motion)
      • Stock price movements
      • Evolution of gene frequencies
      • Spread of diseases
    </p>
    <p style="margin-top: 16px; font-style: italic;">
      "The casino doesn't beat the player. It just gives him the opportunity to beat himself." — Nicholas Dandolos
    </p>
  </div>
</div>

<script>
  // ===== Utility Functions =====
  const $ = sel => document.querySelector(sel);
  const $$ = sel => document.querySelectorAll(sel);
  
  // DOM Elements
  const elements = {
    preset: $('#preset'),
    p: $('#p'),
    target: $('#target'),
    loss: $('#loss'),
    unit: $('#unit'),
    strategy: $('#strategy'),
    paths: $('#paths'),
    runBtn: $('#run'),
    bigProb: $('#bigProb'),
    bigBar: $('#bigBar'),
    ruinProb: $('#ruinProb'),
    ruinBar: $('#ruinBar'),
    wheel: $('#wheel'),
    spinBtn: $('#spinOnce'),
    bigOutcome: $('#bigOutcome'),
    playBtn: $('#play'),
    pauseBtn: $('#pause'),
    stepBtn: $('#step'),
    speed: $('#speed'),
    liveStatus: $('#liveStatus'),
    analyticNote: $('#analyticNote'),
    selfBtn: $('#selfTest'),
    selfNote: $('#selfNote')
  };

  // ===== Math Utilities =====
  function clamp01(x) { 
    return Math.max(0, Math.min(1, x)); 
  }
  
  function formatPercent(x) { 
    if (!isFinite(x)) return '–%';
    const pct = 100 * x;
    if (pct < 0.01) return pct.toFixed(4) + '%';
    if (pct < 1) return pct.toFixed(3) + '%';
    if (pct < 10) return pct.toFixed(2) + '%';
    return pct.toFixed(1) + '%';
  }
  
  function sizeCanvas(canvas) { 
    const ratio = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * ratio;
    canvas.height = rect.height * ratio;
    const ctx = canvas.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return ctx;
  }
  
  function clearCanvas(canvas) { 
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return ctx;
  }

  // Seeded random number generator for reproducible simulations
  function mulberry32(seed) { 
    return function() { 
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
  
  // Binomial coefficient: C(n, k) = n! / (k! * (n-k)!)
  function binomialCoefficient(n, k) {
    if (k > n || k < 0) return 0;
    if (k === 0 || k === n) return 1;
    
    // Use the multiplicative formula to avoid large factorials
    let result = 1;
    for (let i = 0; i < Math.min(k, n - k); i++) {
      result = result * (n - i) / (i + 1);
    }
    return result;
  }
  
  // Standard normal cumulative distribution function approximation
  function normalCDF(z) {
    // Abramowitz and Stegun approximation
    if (z < -8) return 0;
    if (z > 8) return 1;
    
    const sign = z < 0 ? -1 : 1;
    z = Math.abs(z);
    
    // Constants for the approximation
    const a1 = 0.254829592;
    const a2 = -0.284496736;
    const a3 = 1.421413741;
    const a4 = -1.453152027;
    const a5 = 1.061405429;
    const p = 0.3275911;
    
    const t = 1 / (1 + p * z);
    const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);
    
    return 0.5 + sign * 0.5 * y;
  }

  // ===== Mathematical Models =====
  
  // Gambler's Ruin probability (analytical solution)
  // This calculates the probability of reaching the target before going broke
  function computeRuinProbability(p, targetUnits, lossUnits) {
    if (targetUnits <= 0 || lossUnits <= 0) return 0;
    
    // Special case: fair game (p = 0.5)
    if (Math.abs(p - 0.5) < 1e-12) {
      return lossUnits / (targetUnits + lossUnits);
    }
    
    // General case: unfair game
    const q = 1 - p;
    
    // Avoid numerical issues with extreme probabilities
    if (p < 0.01) return 0;
    if (p > 0.99) return 1;
    
    const ratio = q / p;
    
    // For very large exponents, use approximations to avoid infinity
    const maxExp = targetUnits + lossUnits;
    if (maxExp > 500) {
      // For large number of units, use limiting behavior
      if (ratio > 1) {
        // House advantage: probability approaches 0
        return Math.max(0, Math.pow(ratio, -targetUnits));
      } else if (ratio < 1) {
        // Player advantage: probability approaches 1
        return Math.min(1, 1 - Math.pow(ratio, lossUnits));
      }
    }
    
    const numerator = 1 - Math.pow(ratio, lossUnits);
    const denominator = 1 - Math.pow(ratio, targetUnits + lossUnits);
    
    // Avoid division by zero
    if (Math.abs(denominator) < 1e-10) return 0.5;
    
    return Math.max(0, Math.min(1, numerator / denominator));
  }

  // ===== Simulation Engines =====
  
  // Fixed bet strategy simulation
  function simulateFixedBets({ p, target, loss, unit, nPaths, maxSteps = 200000, sampleEvery = 10, rng = Math.random }) {
    const targetUnits = Math.max(1, Math.floor(target / unit));
    const lossUnits = Math.max(1, Math.floor(loss / unit));
    const paths = [];
    let successCount = 0;
    const durations = [];
    const outcomes = []; // Track win/loss for each path
    
    for (let i = 0; i < nPaths; i++) {
      let bankroll = 0;
      let steps = 0;
      const trajectory = [[0, 0]];
      
      while (bankroll > -lossUnits && bankroll < targetUnits && steps < maxSteps) {
        bankroll += rng() < p ? 1 : -1;
        steps++;
        
        if (steps % sampleEvery === 0) {
          trajectory.push([steps, bankroll]);
        }
      }
      
      const finalPosition = Math.max(-lossUnits, Math.min(targetUnits, bankroll));
      trajectory.push([steps, finalPosition]);
      
      const won = finalPosition >= targetUnits;
      if (won) {
        successCount++;
      }
      
      paths.push(trajectory);
      durations.push(steps);
      outcomes.push(won);
    }
    
    return {
      paths,
      successCount,
      probability: successCount / nPaths,
      durations,
      outcomes,
      targetUnits,
      lossUnits
    };
  }

  // Martingale strategy simulation
  function simulateMartingale({ p, target, loss, unit, nPaths, maxSteps = 200000, rng = Math.random }) {
    const paths = [];
    let successCount = 0;
    const durations = [];
    const outcomes = [];
    
    for (let i = 0; i < nPaths; i++) {
      let bankroll = 0;
      let bet = unit;
      let steps = 0;
      const trajectory = [[0, 0]];
      
      while (bankroll > -loss && bankroll < target && steps < maxSteps) {
        // Calculate maximum affordable bet
        const maxBet = Math.min(
          bet,
          loss + bankroll,  // Can't bet more than we can afford to lose
          target - bankroll  // Don't bet more than needed to reach target
        );
        
        const win = rng() < p;
        bankroll += win ? maxBet : -maxBet;
        steps++;
        
        // Update bet size: reset on win, double on loss
        if (win) {
          bet = unit;
        } else {
          bet = Math.min(bet * 2, target - bankroll, loss + bankroll);
        }
        
        if (steps % 10 === 0) {
          trajectory.push([steps, bankroll]);
        }
      }
      
      const finalPosition = Math.max(-loss, Math.min(target, bankroll));
      trajectory.push([steps, finalPosition]);
      
      const won = finalPosition >= target;
      if (won) {
        successCount++;
      }
      
      paths.push(trajectory);
      durations.push(steps);
      outcomes.push(won);
    }
    
    return {
      paths,
      successCount,
      probability: successCount / nPaths,
      durations,
      outcomes
    };
  }

  // ===== Visualization Functions =====
  
  function drawWheelChart() {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const canvas = $('#wheelChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const centerX = w / 2;
    const centerY = h / 2;
    const radius = Math.min(w, h) / 2 - 20;
    
    // Draw background circle
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.2)';
    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Draw probability arc
    const gradient = ctx.createLinearGradient(centerX - radius, centerY, centerX + radius, centerY);
    gradient.addColorStop(0, '#6C1AFF');
    gradient.addColorStop(1, '#9D4DFF');
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * p);
    ctx.stroke();
    
    // Draw center text
    ctx.fillStyle = '#F8F1FF';
    ctx.font = 'bold 32px Inter, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(formatPercent(p), centerX, centerY - 10);
    
    // Draw label
    ctx.font = '14px Inter, system-ui';
    ctx.fillStyle = '#B8B3C8';
    ctx.fillText('Your Odds', centerX, centerY + 20);
    
    // Draw comparison text
    ctx.font = '12px Inter, system-ui';
    ctx.fillStyle = p >= 0.5 ? '#4ADE80' : '#FF4D88';
    const edge = ((0.5 - p) * 100).toFixed(1);
    ctx.fillText(p >= 0.5 ? '✓ Advantage!' : `House edge: ${Math.abs(edge)}%`, centerX, centerY + 40);
  }

  function drawPathsChart(paths, target, loss) {
    const canvas = $('#pathsChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    // Calculate chart dimensions
    const margin = { left: 50, right: 20, top: 20, bottom: 40 };
    const chartWidth = w - margin.left - margin.right;
    const chartHeight = h - margin.top - margin.bottom;
    
    // Find maximum time for x-axis scaling
    let maxTime = 0;
    paths.forEach(path => {
      const lastPoint = path[path.length - 1];
      if (lastPoint[0] > maxTime) maxTime = lastPoint[0];
    });
    maxTime = Math.max(maxTime, 100); // Ensure minimum scale
    
    // Scaling functions - Fixed to properly map values to canvas coordinates
    const xScale = t => margin.left + (t / maxTime) * chartWidth;
    const yScale = y => {
      // Map from [-loss, target] to [bottom, top] of chart
      const normalized = (y + loss) / (target + loss);
      return margin.top + chartHeight * (1 - normalized);
    };
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw target line (success)
    ctx.strokeStyle = '#6C1AFF';
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(margin.left, yScale(target));
    ctx.lineTo(w - margin.right, yScale(target));
    ctx.stroke();
    
    // Draw ruin line (failure)
    ctx.strokeStyle = '#FF1A4D';
    ctx.beginPath();
    ctx.moveTo(margin.left, yScale(-loss));
    ctx.lineTo(w - margin.right, yScale(-loss));
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw paths
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4;
    paths.forEach(path => {
      const lastPoint = path[path.length - 1];
      const success = lastPoint[1] >= target;
      
      // Color based on outcome
      ctx.strokeStyle = success ? '#9D4DFF' : '#FF4D88';
      
      ctx.beginPath();
      path.forEach(([t, y], i) => {
        const x = xScale(t);
        const yPos = yScale(y);
        if (i === 0) {
          ctx.moveTo(x, yPos);
        } else {
          ctx.lineTo(x, yPos);
        }
      });
      ctx.stroke();
    });
    ctx.globalAlpha = 1;
    
    // Draw labels
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '12px Inter, system-ui';
    ctx.fillText('Target (+$' + target + ')', w - margin.right - 100, yScale(target) - 8);
    ctx.fillText('Ruin (−$' + loss + ')', w - margin.right - 100, yScale(-loss) - 8);
    ctx.fillText('Time (steps)', w / 2, h - 10);
    
    // Y-axis label
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Bankroll ($)', 0, 0);
    ctx.restore();
  }

  function drawHistogram(durations, outcomes) {
    const canvas = $('#histChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    if (!durations || durations.length === 0) return;
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    const margin = { left: 50, right: 20, top: 20, bottom: 40 };
    const chartWidth = w - margin.left - margin.right;
    const chartHeight = h - margin.top - margin.bottom;
    
    // Separate wins and losses
    const wins = [];
    const losses = [];
    
    durations.forEach((duration, i) => {
      const won = outcomes ? outcomes[i] : (i % 2 === 0); // Use outcomes if provided
      if (won) {
        wins.push(duration);
      } else {
        losses.push(duration);
      }
    });
    
    // Create histogram bins for both wins and losses
    const maxDuration = Math.max(...durations);
    const numBins = 20;
    const binWidth = Math.ceil(maxDuration / numBins);
    const winHistogram = new Array(numBins).fill(0);
    const lossHistogram = new Array(numBins).fill(0);
    
    wins.forEach(duration => {
      const binIndex = Math.min(numBins - 1, Math.floor(duration / binWidth));
      winHistogram[binIndex]++;
    });
    
    losses.forEach(duration => {
      const binIndex = Math.min(numBins - 1, Math.floor(duration / binWidth));
      lossHistogram[binIndex]++;
    });
    
    const maxCount = Math.max(...winHistogram, ...lossHistogram);
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw bars (stacked: wins on top, losses on bottom)
    const barGap = 2;
    const actualBarWidth = (chartWidth / numBins) - barGap;
    
    for (let i = 0; i < numBins; i++) {
      const x = margin.left + i * (chartWidth / numBins) + barGap / 2;
      
      // Draw loss bar (red)
      if (lossHistogram[i] > 0) {
        const lossHeight = (lossHistogram[i] / maxCount) * chartHeight * 0.8;
        const lossY = margin.top + chartHeight - lossHeight;
        
        const lossGradient = ctx.createLinearGradient(x, lossY, x, lossY + lossHeight);
        lossGradient.addColorStop(0, '#FF4D88');
        lossGradient.addColorStop(1, '#FF1A4D');
        ctx.fillStyle = lossGradient;
        ctx.fillRect(x, lossY, actualBarWidth, lossHeight);
      }
      
      // Draw win bar (purple) above loss bar
      if (winHistogram[i] > 0) {
        const winHeight = (winHistogram[i] / maxCount) * chartHeight * 0.8;
        const lossHeight = (lossHistogram[i] / maxCount) * chartHeight * 0.8;
        const winY = margin.top + chartHeight - lossHeight - winHeight;
        
        const winGradient = ctx.createLinearGradient(x, winY, x, winY + winHeight);
        winGradient.addColorStop(0, '#9D4DFF');
        winGradient.addColorStop(1, '#6C1AFF');
        ctx.fillStyle = winGradient;
        ctx.fillRect(x, winY, actualBarWidth, winHeight);
      }
    }
    
    // Draw legend
    ctx.fillStyle = '#6C1AFF';
    ctx.fillRect(w - 150, margin.top + 10, 15, 15);
    ctx.fillStyle = '#F8F1FF';
    ctx.font = 'bold 12px Inter, system-ui';
    ctx.fillText('Won $', w - 130, margin.top + 22);
    
    ctx.fillStyle = '#FF1A4D';
    ctx.fillRect(w - 150, margin.top + 35, 15, 15);
    ctx.fillStyle = '#F8F1FF';
    ctx.fillText('Lost $', w - 130, margin.top + 47);
    
    // Add statistics
    const winRate = (wins.length / durations.length * 100).toFixed(1);
    const avgWinTime = wins.length > 0 ? Math.round(wins.reduce((a, b) => a + b, 0) / wins.length) : 0;
    const avgLossTime = losses.length > 0 ? Math.round(losses.reduce((a, b) => a + b, 0) / losses.length) : 0;
    
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '11px Inter, system-ui';
    ctx.textAlign = 'left';
    ctx.fillText(`Win rate: ${winRate}%`, margin.left + 10, margin.top + 15);
    ctx.fillText(`Avg win: ${avgWinTime} steps`, margin.left + 10, margin.top + 30);
    ctx.fillText(`Avg loss: ${avgLossTime} steps`, margin.left + 10, margin.top + 45);
    
    // Draw labels
    ctx.textAlign = 'center';
    ctx.font = '12px Inter, system-ui';
    ctx.fillText('Duration (number of bets)', w / 2, h - 10);
    
    // Draw x-axis labels for context
    for (let i = 0; i <= 4; i++) {
      const labelX = margin.left + (i / 4) * chartWidth;
      const labelValue = Math.round((i / 4) * maxDuration);
      ctx.fillText(labelValue.toString(), labelX, h - margin.bottom + 15);
    }
    
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Number of games', 0, 0);
    ctx.restore();
  }

  function drawComparisonChart(target, loss) {
    const canvas = $('#compareChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    const margin = { left: 60, right: 20, top: 40, bottom: 60 };
    const chartWidth = w - margin.left - margin.right;
    const chartHeight = h - margin.top - margin.bottom;
    
    // Get current house edge probability (e.g., 47.37% for American roulette)
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    
    // Generate logarithmic scale for number of bets from 1 to 10,000
    const betCounts = [1, 2, 3, 5, 10, 20, 30, 50, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000];
    const probabilities = [];
    
    // Calculate probability of being ahead for each bet count
    betCounts.forEach(numBets => {
      if (numBets === 1) {
        // For single bet, it's just the probability of winning that bet
        probabilities.push(p);
      } else {
        // For multiple bets, we need to calculate the probability of being ahead
        // after exactly numBets bets. This is fundamentally different from gambler's ruin.
        // We want P(wins > losses after numBets bets) = P(wins > numBets/2)
        
        let prob = 0;
        
        // For small numbers of bets, calculate exactly using binomial distribution
        if (numBets <= 50) {
          // Calculate P(X > numBets/2) where X ~ Binomial(numBets, p)
          // This means we need more than half the bets to be wins
          const minWinsToBeAhead = Math.floor(numBets / 2) + 1;
          
          for (let wins = minWinsToBeAhead; wins <= numBets; wins++) {
            // Binomial probability: C(n,k) * p^k * (1-p)^(n-k)
            const binomialCoeff = binomialCoefficient(numBets, wins);
            const probThisOutcome = binomialCoeff * Math.pow(p, wins) * Math.pow(1 - p, numBets - wins);
            prob += probThisOutcome;
          }
        } else {
          // For large numbers of bets, use normal approximation
          const mean = numBets * p;
          const variance = numBets * p * (1 - p);
          const stdDev = Math.sqrt(variance);
          
          // We want P(wins > numBets/2) = P(wins > losses)
          // With continuity correction: P(X > numBets/2) ≈ P(X >= (numBets/2) + 0.5)
          const threshold = numBets / 2 + 0.5;
          
          // Convert to standard normal: Z = (X - mean) / stdDev
          const z = (threshold - mean) / stdDev;
          
          // P(X > threshold) = 1 - Φ(z) where Φ is the standard normal CDF
          prob = 1 - normalCDF(z);
        }
        
        probabilities.push(Math.max(0, Math.min(1, prob)));
      }
    });
    
    // Convert bet counts to log scale for x-axis positioning
    const logScale = (n) => Math.log10(n);
    const minLog = logScale(1);
    const maxLog = logScale(10000);
    
    const xScale = (betCount) => {
      return margin.left + ((logScale(betCount) - minLog) / (maxLog - minLog)) * chartWidth;
    };
    
    const yScale = (probability) => {
      return margin.top + (1 - probability) * chartHeight;
    };
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw horizontal grid lines and y-axis labels
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.1)';
    ctx.setLineDash([2, 4]);
    ctx.font = '12px Inter, system-ui';
    ctx.fillStyle = '#B8B3C8';
    ctx.textAlign = 'right';
    
    const yLabels = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
    yLabels.forEach(percent => {
      const y = margin.top + ((100 - percent) / 100) * chartHeight;
      
      // Draw grid line
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(w - margin.right, y);
      ctx.stroke();
      
      // Draw y-axis label
      ctx.fillText(percent + '%', margin.left - 5, y + 4);
    });
    ctx.setLineDash([]);
    
    // Draw vertical grid lines for x-axis (log scale)
    const xLabels = [1, 10, 100, 1000, 10000];
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.1)';
    ctx.setLineDash([2, 4]);
    ctx.textAlign = 'center';
    ctx.font = '11px Inter, system-ui';
    
    xLabels.forEach(betCount => {
      const x = xScale(betCount);
      
      // Draw grid line
      ctx.beginPath();
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, h - margin.bottom);
      ctx.stroke();
      
      // Draw x-axis label
      ctx.fillText(betCount.toLocaleString(), x, h - margin.bottom + 20);
    });
    ctx.setLineDash([]);
    
    // Draw the main curve showing probability decay
    ctx.strokeStyle = '#FF1A4D';
    ctx.lineWidth = 4;
    ctx.beginPath();
    probabilities.forEach((prob, i) => {
      const x = xScale(betCounts[i]);
      const y = yScale(prob);
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    ctx.stroke();
    
    // Add data points as circles
    ctx.fillStyle = '#FF1A4D';
    probabilities.forEach((prob, i) => {
      const x = xScale(betCounts[i]);
      const y = yScale(prob);
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Add danger zone shading (below 10%)
    const dangerY = yScale(0.1);
    ctx.fillStyle = 'rgba(255, 26, 77, 0.1)';
    ctx.fillRect(margin.left, dangerY, chartWidth, h - margin.bottom - dangerY);
    
    // Add danger zone label
    ctx.fillStyle = '#FF1A4D';
    ctx.font = 'bold 12px Inter, system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('DANGER ZONE', margin.left + 10, dangerY - 8);
    ctx.font = '10px Inter, system-ui';
    ctx.fillStyle = '#B8B3C8';
    ctx.fillText('Less than 10% chance of success', margin.left + 10, dangerY - 22);
    
    // Add key annotations with arrows
    ctx.fillStyle = '#F8F1FF';
    ctx.font = 'bold 11px Inter, system-ui';
    
    // Annotation for 1 bet
    const x1 = xScale(1);
    const y1 = yScale(probabilities[0]);
    ctx.textAlign = 'center';
    ctx.fillText(`${(probabilities[0] * 100).toFixed(1)}%`, x1, y1 - 15);
    ctx.font = '9px Inter, system-ui';
    ctx.fillStyle = '#B8B3C8';
    ctx.fillText('Single bet', x1, y1 - 30);
    
    // Draw arrow pointing to 1 bet
    ctx.strokeStyle = '#F8F1FF';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x1, y1 - 12);
    ctx.lineTo(x1, y1 - 5);
    ctx.stroke();
    
    // Annotation for 1000 bets (if it's low enough)
    const index1000 = betCounts.indexOf(1000);
    if (index1000 !== -1 && probabilities[index1000] < 0.15) {
      const x1000 = xScale(1000);
      const y1000 = yScale(probabilities[index1000]);
      ctx.fillStyle = '#FF4D88';
      ctx.font = 'bold 11px Inter, system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`${(probabilities[index1000] * 100).toFixed(1)}%`, x1000, y1000 - 15);
      ctx.font = '9px Inter, system-ui';
      ctx.fillText('1,000 bets', x1000, y1000 - 30);
      
      // Draw arrow
      ctx.strokeStyle = '#FF4D88';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x1000, y1000 - 12);
      ctx.lineTo(x1000, y1000 - 5);
      ctx.stroke();
    }
    
    // Main title and explanation
    ctx.fillStyle = '#F8F1FF';
    ctx.font = 'bold 16px Inter, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Why The House Always Wins: The Compound Effect', w / 2, margin.top - 15);
    
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '12px Inter, system-ui';
    ctx.fillText(`With ${(p * 100).toFixed(1)}% win rate, your chance of being ahead drops as you play more`, w / 2, margin.top - 2);
    
    // Draw axis labels
    ctx.fillStyle = '#B8B3C8';
    ctx.font = 'bold 13px Inter, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Number of Bets (Log Scale)', w / 2, h - 10);
    
    // Y-axis label
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.textAlign = 'center';
    ctx.font = 'bold 13px Inter, system-ui';
    ctx.fillText('Probability of Ending Up Ahead', 0, 0);
    ctx.restore();
    
    // Add legend box in top right
    const legendX = w - margin.right - 180;
    const legendY = margin.top + 10;
    
    // Legend background
    ctx.fillStyle = 'rgba(26, 31, 58, 0.9)';
    ctx.fillRect(legendX, legendY, 170, 80);
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(legendX, legendY, 170, 80);
    
    // Legend content
    ctx.fillStyle = '#F8F1FF';
    ctx.font = 'bold 12px Inter, system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Key Insight:', legendX + 10, legendY + 20);
    
    ctx.font = '11px Inter, system-ui';
    ctx.fillStyle = '#B8B3C8';
    ctx.fillText('• More bets = more chances', legendX + 10, legendY + 35);
    ctx.fillText('  for house edge to work', legendX + 10, legendY + 50);
    ctx.fillText('• Law of large numbers', legendX + 10, legendY + 65);
    ctx.fillText('  guarantees house wins', legendX + 10, legendY + 80);
  }

  // ===== Wheel Animation =====
  function spinWheel(p) {
    const wheel = elements.wheel;
    const duration = 1500;
    const spins = 5 + Math.random() * 3;
    const finalRotation = spins * 360 + Math.random() * 360;
    
    wheel.animate([
      { transform: 'rotate(0deg)' },
      { transform: `rotate(${finalRotation}deg)` }
    ], {
      duration: duration,
      easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)'
    });
    
    setTimeout(() => {
      const won = Math.random() < p;
      elements.bigOutcome.textContent = won ? '🎉 WIN $100!' : '😔 LOSE $100';
      elements.bigOutcome.className = won ? 'pill success' : 'pill danger';
      
      // Add a brief explanation
      const explanation = won 
        ? `Nice! You had a ${(p * 100).toFixed(1)}% chance and got lucky!`
        : `Tough luck. You had a ${((1-p) * 100).toFixed(1)}% chance of losing.`;
      
      // Create or update explanation element
      let explainEl = document.getElementById('spinExplanation');
      if (!explainEl) {
        explainEl = document.createElement('p');
        explainEl.id = 'spinExplanation';
        explainEl.style.cssText = 'font-size: 13px; color: var(--muted); margin-top: 10px;';
        elements.bigOutcome.parentNode.appendChild(explainEl);
      }
      explainEl.textContent = explanation;
    }, duration);
  }

  // ===== Live Simulation State =====
  let liveSimulation = {
    active: false,
    state: null,
    animationFrame: null,
    rng: mulberry32(Date.now())
  };

  function resetLiveSimulation() {
    liveSimulation.active = false;
    liveSimulation.state = null;
    if (liveSimulation.animationFrame) {
      cancelAnimationFrame(liveSimulation.animationFrame);
    }
    elements.liveStatus.textContent = 'Ready';
    elements.liveStatus.className = 'pill';
  }

  function startLiveSimulation() {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const target = Math.max(1, parseFloat(elements.target.value || '100'));
    const loss = Math.max(1, parseFloat(elements.loss.value || '10000'));
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const strategy = elements.strategy.value;
    
    liveSimulation.state = {
      p, target, loss, unit, strategy,
      time: 0,
      bankroll: 0,
      bet: unit,
      trajectory: [[0, 0]]
    };
    
    liveSimulation.active = true;
    liveSimulation.rng = mulberry32(Date.now());
    elements.liveStatus.textContent = 'Running';
    elements.liveStatus.className = 'pill success';
    
    animateLiveSimulation();
  }

  function stepLiveSimulation() {
    if (!liveSimulation.state) {
      startLiveSimulation();
      return;
    }
    
    const { p, target, loss, unit, strategy } = liveSimulation.state;
    
    if (strategy === 'unit') {
      // Fixed bet strategy
      const won = liveSimulation.rng() < p;
      liveSimulation.state.bankroll += won ? unit : -unit;
    } else {
      // Martingale strategy
      const maxBet = Math.min(
        liveSimulation.state.bet,
        loss + liveSimulation.state.bankroll,
        target - liveSimulation.state.bankroll
      );
      
      const won = liveSimulation.rng() < p;
      liveSimulation.state.bankroll += won ? maxBet : -maxBet;
      
      if (won) {
        liveSimulation.state.bet = unit;
      } else {
        liveSimulation.state.bet = Math.min(
          liveSimulation.state.bet * 2,
          target - liveSimulation.state.bankroll,
          loss + liveSimulation.state.bankroll
        );
      }
    }
    
    liveSimulation.state.time++;
    
    if (liveSimulation.state.time % 10 === 0) {
      liveSimulation.state.trajectory.push([
        liveSimulation.state.time,
        liveSimulation.state.bankroll
      ]);
    }
    
    // Check for termination
    if (liveSimulation.state.bankroll >= target) {
      liveSimulation.active = false;
      elements.liveStatus.textContent = 'Success!';
      elements.liveStatus.className = 'pill success';
      liveSimulation.state.trajectory.push([
        liveSimulation.state.time,
        target
      ]);
    } else if (liveSimulation.state.bankroll <= -loss) {
      liveSimulation.active = false;
      elements.liveStatus.textContent = 'Ruined';
      elements.liveStatus.className = 'pill danger';
      liveSimulation.state.trajectory.push([
        liveSimulation.state.time,
        -loss
      ]);
    }
    
    // Update visualization
    drawPathsChart([liveSimulation.state.trajectory], target, loss);
  }

  function animateLiveSimulation() {
    if (!liveSimulation.active) return;
    
    const speed = parseInt(elements.speed.value, 10);
    const delay = 1000 / Math.max(1, speed);
    
    setTimeout(() => {
      stepLiveSimulation();
      if (liveSimulation.active) {
        liveSimulation.animationFrame = requestAnimationFrame(animateLiveSimulation);
      }
    }, delay);
  }

  // ===== Main Update Function =====
  function updateSimulation() {
    // Handle preset selection
    if (elements.preset.value === 'american') {
      elements.p.value = (18/38).toFixed(4);
    } else if (elements.preset.value === 'european') {
      elements.p.value = (18/37).toFixed(4);
    }
    
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const target = Math.max(1, parseFloat(elements.target.value || '100'));
    const loss = Math.max(1, parseFloat(elements.loss.value || '10000'));
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const strategy = elements.strategy.value;
    
    // Update single bet display
    elements.bigProb.textContent = formatPercent(p);
    elements.bigBar.style.width = (100 * p).toFixed(2) + '%';
    drawWheelChart();
    
    // Update multi-bet display
    if (strategy === 'unit') {
      const targetUnits = Math.max(1, Math.floor(target / unit));
      const lossUnits = Math.max(1, Math.floor(loss / unit));
      const probability = computeRuinProbability(p, targetUnits, lossUnits);
      
      elements.ruinProb.textContent = formatPercent(probability);
      elements.ruinBar.style.width = (100 * probability).toFixed(2) + '%';
      
      const successChance = probability * 100;
      const lossChance = (1 - probability) * 100;
      
      elements.analyticNote.innerHTML = `
        📊 <strong>What's happening:</strong> With $${unit} bets, you need to win ${targetUnits} more times than you lose 
        before losing ${lossUnits} times total. <br>
        <strong>Your chances:</strong> ${successChance.toFixed(1)}% success vs ${lossChance.toFixed(1)}% failure. 
        That's like flipping ${Math.round(100/successChance)} coins and hoping at least one lands heads!
      `;
    } else {
      elements.ruinProb.textContent = 'Calculating...';
      elements.ruinBar.style.width = '0%';
      elements.analyticNote.innerHTML = `
        ⚠️ <strong>Martingale Strategy:</strong> You double your bet after each loss, trying to recover all losses with one win. 
        This seems smart but is actually very dangerous! You can hit the table limit or run out of money fast. 
        We need to simulate this because the math gets too complex for a simple formula.
      `;
    }
    
    // Generate sample paths for visualization
    const rng = mulberry32(42);
    let samplePaths;
    
    if (strategy === 'unit') {
      const result = simulateFixedBets({
        p, target, loss, unit,
        nPaths: 25,
        rng
      });
      samplePaths = result.paths.map(path => 
        path.map(([t, y]) => [t, y * unit])
      );
    } else {
      const result = simulateMartingale({
        p, target, loss, unit,
        nPaths: 25,
        rng
      });
      samplePaths = result.paths;
    }
    
    drawPathsChart(samplePaths, target, loss);
    drawComparisonChart(target, loss);
    
    // Draw empty histogram with instructions
    drawEmptyHistogram();
  }
  
  // Function to draw an empty histogram with instructions
  function drawEmptyHistogram() {
    const canvas = $('#histChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    const margin = { left: 50, right: 20, top: 20, bottom: 40 };
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw message
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '14px Inter, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Click "Run Simulation" to see duration distribution', w / 2, h / 2);
    ctx.fillText('This will show how long each strategy typically takes', w / 2, h / 2 + 20);
    
    // Draw axis labels
    ctx.font = '12px Inter, system-ui';
    ctx.fillText('Duration (steps)', w / 2, h - 10);
    
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Frequency', 0, 0);
    ctx.restore();
  }

  // ===== Monte Carlo Simulation =====
  function runMonteCarloSimulation() {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const target = Math.max(1, parseFloat(elements.target.value || '100'));
    const loss = Math.max(1, parseFloat(elements.loss.value || '10000'));
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const nPaths = Math.max(100, parseInt(elements.paths.value || '5000'));
    const strategy = elements.strategy.value;
    
    elements.runBtn.textContent = 'Simulating...';
    elements.runBtn.disabled = true;
    
    // Run simulation asynchronously
    setTimeout(() => {
      const rng = mulberry32(12345);
      let result;
      
      if (strategy === 'unit') {
        result = simulateFixedBets({
          p, target, loss, unit, nPaths, rng
        });
        
        const targetUnits = result.targetUnits;
        const lossUnits = result.lossUnits;
        const theoretical = computeRuinProbability(p, targetUnits, lossUnits);
        
        elements.ruinProb.innerHTML = `
          ${formatPercent(theoretical)} <span style="font-size: 12px; opacity: 0.8;">(exact)</span><br>
          <span style="font-size: 14px; opacity: 0.7;">
            ${formatPercent(result.probability)} (${nPaths.toLocaleString()} simulations)
          </span>
        `;
        
        // Convert paths back to dollars for display
        const displayPaths = result.paths.slice(0, 50).map(path => 
          path.map(([t, y]) => [t, y * unit])
        );
        drawPathsChart(displayPaths, target, loss);
      } else {
        result = simulateMartingale({
          p, target, loss, unit, nPaths, rng
        });
        
        elements.ruinProb.innerHTML = `
          ${formatPercent(result.probability)}<br>
          <span style="font-size: 14px; opacity: 0.7;">
            (${nPaths.toLocaleString()} simulations)
          </span>
        `;
        
        drawPathsChart(result.paths.slice(0, 50), target, loss);
      }
      
      elements.ruinBar.style.width = (100 * result.probability).toFixed(2) + '%';
      drawHistogram(result.durations, result.outcomes);
      
      elements.runBtn.textContent = 'Run Monte Carlo Simulation';
      elements.runBtn.disabled = false;
    }, 100);
  }

  // ===== Verification Tests =====
  function runVerificationTests() {
    elements.selfBtn.disabled = true;
    elements.selfNote.textContent = 'Running tests...';
    elements.selfNote.className = 'pill loading';
    
    setTimeout(() => {
      const tests = [];
      
      // Test 1: Fair game (p = 0.5)
      const fairProb = computeRuinProbability(0.5, 10, 10);
      const fairExpected = 0.5;
      const test1Pass = Math.abs(fairProb - fairExpected) < 1e-10;
      tests.push({
        name: 'Fair Game',
        pass: test1Pass,
        details: `P(0.5, 10, 10) = ${fairProb.toFixed(6)}, expected ${fairExpected}`
      });
      
      // Test 2: Monte Carlo convergence
      const p = 18/38;
      const theoretical = computeRuinProbability(p, 5, 5);
      const mcResult = simulateFixedBets({
        p, target: 5, loss: 5, unit: 1,
        nPaths: 10000,
        rng: mulberry32(77)
      });
      const test2Pass = Math.abs(theoretical - mcResult.probability) < 0.02;
      tests.push({
        name: 'MC Convergence',
        pass: test2Pass,
        details: `Theory: ${theoretical.toFixed(4)}, MC: ${mcResult.probability.toFixed(4)}`
      });
      
      // Test 3: Edge cases
      const edgeCase1 = computeRuinProbability(0, 10, 10);
      const edgeCase2 = computeRuinProbability(1, 10, 10);
      const test3Pass = edgeCase1 === 0 && edgeCase2 === 1;
      tests.push({
        name: 'Edge Cases',
        pass: test3Pass,
        details: `P(0) = ${edgeCase1}, P(1) = ${edgeCase2}`
      });
      
      // Display results
      const allPass = tests.every(t => t.pass);
      
      if (allPass) {
        elements.selfNote.textContent = 'All tests passed!';
        elements.selfNote.className = 'pill success';
      } else {
        const failedTests = tests.filter(t => !t.pass).map(t => t.name).join(', ');
        elements.selfNote.textContent = `Failed: ${failedTests}`;
        elements.selfNote.className = 'pill danger';
      }
      
      // Log details to console
      console.group('Verification Test Results');
      tests.forEach(test => {
        console.log(`${test.pass ? '✅' : '❌'} ${test.name}: ${test.details}`);
      });
      console.groupEnd();
      
      elements.selfBtn.disabled = false;
    }, 500);
  }

  // ===== Event Listeners =====
  elements.preset.addEventListener('change', updateSimulation);
  elements.p.addEventListener('input', updateSimulation);
  elements.target.addEventListener('input', updateSimulation);
  elements.loss.addEventListener('input', updateSimulation);
  elements.unit.addEventListener('input', updateSimulation);
  elements.strategy.addEventListener('change', updateSimulation);
  
  elements.runBtn.addEventListener('click', runMonteCarloSimulation);
  elements.spinBtn.addEventListener('click', () => {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    spinWheel(p);
  });
  
  elements.playBtn.addEventListener('click', () => {
    if (!liveSimulation.active) {
      resetLiveSimulation();
      startLiveSimulation();
    }
  });
  
  elements.pauseBtn.addEventListener('click', () => {
    liveSimulation.active = false;
    elements.liveStatus.textContent = 'Paused';
    elements.liveStatus.className = 'pill warning';
  });
  
  elements.stepBtn.addEventListener('click', () => {
    if (liveSimulation.active) {
      liveSimulation.active = false;
    }
    stepLiveSimulation();
  });
  
  elements.selfBtn.addEventListener('click', runVerificationTests);
  
  // Handle window resize
  window.addEventListener('resize', () => {
    updateSimulation();
  });
  
  // ===== Initialize =====
  updateSimulation();
</script>
</body>
</html>