<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Gambler's Dilemma: One Big Bet vs Many Small Bets</title>
  <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    /* ===== Enhanced Color Palette ===== */
    :root {
      --primary-red: #FF1A4D;
      --primary-purple: #6C1AFF;
      --dark-bg: #0A0E27;
      --content-bg: #1A1F3A;
      --accent-purple: #9D4DFF;
      --accent-red: #FF4D88;
      --ink: #F8F1FF;
      --muted: #B8B3C8;
      --success: #4ADE80;
      --warning: #FCD34D;
      --border: rgba(157, 77, 255, 0.3);
      --glass: rgba(255, 255, 255, 0.05);
    }

    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      background: linear-gradient(135deg, #0A0E27 0%, #1A0A29 50%, #2D0A3D 100%);
      color: var(--ink);
      font: 16px/1.6 'Inter', system-ui, -apple-system, sans-serif;
      scroll-behavior: smooth;
    }

    /* ===== Typography ===== */
    h1, h2, h3 {
      font-family: 'Russo One', system-ui, sans-serif;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    h1 {
      font-size: clamp(28px, 4vw, 48px);
      margin: 20px 0;
      background: linear-gradient(135deg, var(--accent-purple), var(--accent-red));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
    }

    h2 {
      font-size: 22px;
      margin: 20px 0 12px;
      color: var(--accent-purple);
    }

    h3 {
      font-size: 18px;
      margin: 16px 0 8px;
      color: var(--muted);
    }

    p {
      margin: 12px 0;
      color: var(--muted);
      line-height: 1.7;
    }

    a {
      color: var(--accent-red);
      text-decoration: none;
      transition: opacity 0.2s;
    }

    a:hover {
      opacity: 0.8;
    }

    /* ===== Layout ===== */
    .app {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .hero {
      text-align: center;
      padding: 40px 20px;
      margin-bottom: 40px;
      background: var(--glass);
      border-radius: 24px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
    }

    .story {
      max-width: 800px;
      margin: 0 auto 40px;
      padding: 30px;
      background: var(--glass);
      border-radius: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
    }

    .story-highlight {
      padding: 20px;
      margin: 20px 0;
      background: linear-gradient(135deg, rgba(108, 26, 255, 0.1), rgba(255, 26, 77, 0.05));
      border-left: 4px solid var(--accent-purple);
      border-radius: 8px;
    }

    .grid {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
    }

    @media (max-width: 1100px) {
      .grid { grid-template-columns: 1fr; }
    }

    .card {
      background: linear-gradient(180deg, rgba(108, 26, 255, 0.08), rgba(108, 26, 255, 0.02));
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      transition: transform 0.3s, box-shadow 0.3s;
    }

    .card:hover {
      transform: translateY(-2px);
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
    }

    /* ===== Controls ===== */
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      padding: 28px;
      margin-bottom: 30px;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    input[type="number"], select {
      background: var(--glass);
      border: 1px solid var(--border);
      color: var(--ink);
      padding: 12px;
      border-radius: 12px;
      outline: none;
      font-size: 14px;
      transition: all 0.2s;
    }

    input[type="number"]:focus, select:focus {
      border-color: var(--accent-purple);
      box-shadow: 0 0 0 3px rgba(157, 77, 255, 0.1);
    }

    input[type="range"] {
      width: 100%;
      margin-top: 8px;
    }

    .btn {
      background: linear-gradient(135deg, var(--primary-red), var(--primary-purple));
      color: white;
      border: 0;
      border-radius: 14px;
      padding: 14px 24px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 8px 24px rgba(255, 26, 77, 0.3);
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 13px;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(255, 26, 77, 0.4);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn.ghost {
      background: transparent;
      border: 2px solid var(--border);
      box-shadow: none;
    }

    .btn.ghost:hover {
      border-color: var(--accent-purple);
      box-shadow: 0 0 20px rgba(157, 77, 255, 0.3);
    }

    /* ===== Metrics & Indicators ===== */
    .meter {
      height: 28px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 14px;
      border: 1px solid var(--border);
      overflow: hidden;
      margin: 12px 0;
      position: relative;
    }

    .meter::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .fill {
      height: 100%;
      transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .fill.good {
      background: linear-gradient(90deg, var(--primary-purple), var(--accent-purple));
    }

    .fill.bad {
      background: linear-gradient(90deg, var(--primary-red), #FF7B8A);
    }

    .kpi {
      display: flex;
      align-items: baseline;
      gap: 12px;
      margin: 16px 0;
    }

    .kpi .val {
      font-weight: 800;
      font-size: 36px;
      font-variant-numeric: tabular-nums;
      background: linear-gradient(135deg, var(--ink), var(--accent-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .kpi .sub {
      opacity: 0.7;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* ===== Tags & Pills ===== */
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin: 16px 0;
    }

    .tag {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px dashed var(--border);
      color: var(--muted);
      font-size: 12px;
      font-family: 'Courier New', monospace;
      background: var(--glass);
    }

    .pill {
      padding: 8px 16px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
      background: var(--glass);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .pill.success {
      border-color: var(--success);
      color: var(--success);
      background: rgba(74, 222, 128, 0.1);
    }

    .pill.danger {
      border-color: var(--primary-red);
      color: var(--primary-red);
      background: rgba(255, 26, 77, 0.1);
    }

    /* ===== Wheel Animation ===== */
    .wheelWrap {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 24px;
      align-items: center;
      padding: 20px;
      background: var(--glass);
      border-radius: 16px;
      margin: 20px 0;
    }

    .wheel {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: conic-gradient(
        var(--primary-red) 0 47.37%,
        #1A1F3A 47.37% 50%,
        var(--primary-purple) 50% 97.37%,
        #1A1F3A 97.37% 100%
      );
      border: 8px solid var(--border);
      position: relative;
      box-shadow: 
        inset 0 0 40px rgba(0, 0, 0, 0.6),
        0 0 40px rgba(157, 77, 255, 0.3);
    }

    .peg {
      position: absolute;
      top: -12px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-bottom: 18px solid var(--accent-red);
      filter: drop-shadow(0 0 8px rgba(255, 77, 136, 0.8));
    }

    .needle {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .needle > div {
      width: 3px;
      height: 70%;
      background: linear-gradient(to bottom, var(--accent-red), transparent);
      box-shadow: 0 0 10px var(--accent-red);
    }

    /* ===== Charts ===== */
    canvas {
      display: block;
      width: 100%;
      height: 320px;
      background: linear-gradient(180deg, rgba(157, 77, 255, 0.03), rgba(255, 26, 77, 0.02));
      border-radius: 16px;
      border: 1px solid var(--border);
      margin: 20px 0;
    }

    .viz {
      margin: 20px 0;
    }

    .legend {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin: 16px 0;
      padding: 12px;
      background: var(--glass);
      border-radius: 12px;
    }

    .swatch {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .dot {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      background: var(--accent-purple);
      border: 1px solid var(--border);
    }

    .dot.good { background: var(--primary-purple); }
    .dot.bad { background: var(--primary-red); }

    /* ===== Interactive Elements ===== */
    .inline {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin: 20px 0;
    }

    .caption {
      font-size: 13px;
      color: var(--muted);
      line-height: 1.6;
      margin: 12px 0;
    }

    .footer {
      margin-top: 40px;
      padding: 30px;
      background: var(--glass);
      border-radius: 20px;
      border: 1px solid var(--border);
      text-align: center;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.8;
    }

    .mono {
      font-family: 'Courier New', monospace;
      background: var(--glass);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.95em;
    }

    /* ===== Responsive Design ===== */
    @media (max-width: 768px) {
      .controls { grid-template-columns: 1fr; }
      .wheelWrap { grid-template-columns: 1fr; text-align: center; }
      .wheel { margin: 0 auto; }
      h1 { font-size: 28px; }
      .kpi .val { font-size: 28px; }
    }

    /* ===== Animations ===== */
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .loading {
      animation: pulse 1.5s infinite;
    }

    /* ===== Back Button ===== */
    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: var(--glass);
      color: var(--ink);
      padding: 12px 24px;
      border-radius: 12px;
      text-decoration: none;
      margin-bottom: 30px;
      transition: all 0.3s;
      font-weight: 600;
      border: 1px solid var(--border);
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: translateX(-5px);
      border-color: var(--accent-purple);
    }
  </style>
</head>
<body>
<div class="app">
  <a href="../mathematical-simulations" class="back-button">
    <span>←</span>
    <span>Back to Mathematical Simulations</span>
  </a>

  <div class="hero">
    <h1>The Gambler's Dilemma</h1>
    <p style="font-size: 18px; color: var(--ink); margin: 20px auto; max-width: 800px;">
      An Interactive Mathematical Journey Through Risk, Probability, and the House Edge
    </p>
  </div>

  <div class="story">
    <h2>The Eternal Question</h2>
    <p>
      Imagine you're standing at the edge of possibility. You have a goal: win $100. You have a limit: you can't afford to lose more than $10,000. 
      Before you lies a game with nearly even odds—but not quite. The house always has an edge.
    </p>
    
    <div class="story-highlight">
      <h3>Two Paths Diverge</h3>
      <p>
        <strong>Path One:</strong> Risk it all in one glorious moment. One spin, one bet, one chance at destiny.<br>
        <strong>Path Two:</strong> Play the long game. Many small bets, slowly climbing toward your goal.
      </p>
      <p style="margin-top: 16px;">
        Which path gives you the better chance? The answer might surprise you...
      </p>
    </div>

    <p>
      This interactive demonstration uses Monte Carlo simulations and mathematical analysis to reveal a profound truth about 
      gambling systems: <strong>when the house has an edge, time is your enemy</strong>. Every additional bet compounds the house advantage, 
      slowly but surely tilting the odds further against you.
    </p>
  </div>

  <div class="card controls">
    <h2>Configure Your Experiment</h2>
    <label>Game Type
      <select id="preset">
        <option value="american">American Roulette (House Edge: 5.26%)</option>
        <option value="european">European Roulette (House Edge: 2.70%)</option>
        <option value="custom">Custom Probability</option>
      </select>
    </label>
    <label>Win Probability (p)
      <input id="p" type="number" step="0.0001" min="0" max="1" value="0.4737" />
    </label>
    <label>Target Gain ($)
      <input id="target" type="number" step="1" min="1" value="100" />
    </label>
    <label>Maximum Loss ($)
      <input id="loss" type="number" step="1" min="1" value="10000" />
    </label>
    <label>Unit Bet Size ($)
      <input id="unit" type="number" step="1" min="1" value="1" />
    </label>
    <label>Strategy Type
      <select id="strategy">
        <option value="unit">Conservative (Fixed Bets)</option>
        <option value="martingale">Martingale (Double on Loss)</option>
      </select>
    </label>
    <label>Simulation Paths
      <input id="paths" type="number" step="100" min="100" value="5000" />
    </label>
    <button id="run" class="btn">Run Monte Carlo Simulation</button>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Strategy One: The Bold Gambler</h2>
      <p class="caption">
        Place everything on a single bet. One moment of truth. The house edge strikes only once.
      </p>
      <div class="wheelWrap">
        <div class="wheel" id="wheel">
          <div class="peg"></div>
          <div class="needle"><div></div></div>
        </div>
        <div>
          <div class="kpi">
            <span class="val" id="bigProb">–%</span>
            <span class="sub">Success Probability</span>
          </div>
          <div class="meter">
            <div class="fill good" id="bigBar" style="width:0%"></div>
          </div>
          <div class="row">
            <span class="tag">P(win) = p</span>
            <span class="tag">P(lose) = 1 − p</span>
            <span class="tag">EV = (2p − 1) × bet</span>
          </div>
          <div class="inline">
            <button class="btn ghost" id="spinOnce">Spin the Wheel</button>
            <span class="pill" id="bigOutcome">Ready</span>
          </div>
        </div>
      </div>
      <canvas id="wheelChart"></canvas>
    </div>

    <div class="card">
      <h2>Strategy Two: The Patient Player</h2>
      <p class="caption">
        Many small steps toward the goal. But each step gives the house another chance to win.
      </p>
      <div class="kpi">
        <span class="val" id="ruinProb">–%</span>
        <span class="sub">Success Probability</span>
      </div>
      <div class="meter">
        <div class="fill good" id="ruinBar" style="width:0%"></div>
      </div>
      <p class="caption" id="analyticNote">
        Mathematical formula: <span class="mono">P = [1 − (q/p)^B] / [1 − (q/p)^(A+B)]</span>
      </p>
      <div class="viz">
        <canvas id="pathsChart"></canvas>
        <div class="legend">
          <span class="swatch"><span class="dot good"></span> Sample Paths</span>
          <span class="swatch"><span class="dot"></span> Target Goal</span>
          <span class="swatch"><span class="dot bad"></span> Ruin Threshold</span>
        </div>
      </div>
      <div class="inline">
        <button class="btn" id="play">Start Journey</button>
        <button class="btn ghost" id="pause">Pause</button>
        <button class="btn ghost" id="step">Single Step</button>
        <label style="flex: 1; min-width: 200px;">Simulation Speed
          <input id="speed" type="range" min="1" max="60" value="30" />
        </label>
        <span class="pill" id="liveStatus">Ready</span>
      </div>
    </div>
  </div>

  <div class="grid" style="margin-top: 20px;">
    <div class="card">
      <h2>Time Distribution Analysis</h2>
      <p class="caption">How long does it take to reach the goal or ruin?</p>
      <canvas id="histChart"></canvas>
    </div>
    <div class="card">
      <h2>The House Edge Effect</h2>
      <p class="caption">Watch how the house advantage compounds over multiple bets.</p>
      <canvas id="compareChart"></canvas>
    </div>
  </div>

  <div class="card" style="margin-top: 20px;">
    <h2>Mathematical Verification Suite</h2>
    <p class="caption">
      Our simulations are backed by rigorous mathematical proofs. These tests verify that our code correctly 
      implements the gambler's ruin formulas and that Monte Carlo simulations converge to theoretical values.
    </p>
    <div class="inline">
      <button class="btn" id="selfTest">Run Verification Tests</button>
      <span class="pill" id="selfNote">Not verified</span>
    </div>
    <div class="row" style="margin-top: 20px;">
      <span class="tag">Test 1: Fair Game (p=0.5)</span>
      <span class="tag">Test 2: Monte Carlo Convergence</span>
      <span class="tag">Test 3: Edge Cases</span>
    </div>
  </div>

  <div class="footer">
    <h3>The Mathematics Behind the Magic</h3>
    <p>
      This demonstration implements the classical <strong>Gambler's Ruin</strong> problem, first studied by Blaise Pascal and Pierre de Fermat in 1656.
      The exact probabilities are calculated using recursive formulas derived from Markov chain analysis.
    </p>
    <p style="margin-top: 16px;">
      <strong>Key Insight:</strong> In American roulette (p = 18/38 ≈ 47.37%), the house edge is 5.26%. 
      In European roulette (p = 18/37 ≈ 48.65%), it's 2.70%. 
      These small percentages become devastating over many bets.
    </p>
    <p style="margin-top: 16px; font-style: italic;">
      "The casino doesn't beat the player. It just gives him the opportunity to beat himself." — Nicholas Dandolos
    </p>
  </div>
</div>

<script>
  // ===== Utility Functions =====
  const $ = sel => document.querySelector(sel);
  const $$ = sel => document.querySelectorAll(sel);
  
  // DOM Elements
  const elements = {
    preset: $('#preset'),
    p: $('#p'),
    target: $('#target'),
    loss: $('#loss'),
    unit: $('#unit'),
    strategy: $('#strategy'),
    paths: $('#paths'),
    runBtn: $('#run'),
    bigProb: $('#bigProb'),
    bigBar: $('#bigBar'),
    ruinProb: $('#ruinProb'),
    ruinBar: $('#ruinBar'),
    wheel: $('#wheel'),
    spinBtn: $('#spinOnce'),
    bigOutcome: $('#bigOutcome'),
    playBtn: $('#play'),
    pauseBtn: $('#pause'),
    stepBtn: $('#step'),
    speed: $('#speed'),
    liveStatus: $('#liveStatus'),
    analyticNote: $('#analyticNote'),
    selfBtn: $('#selfTest'),
    selfNote: $('#selfNote')
  };

  // ===== Math Utilities =====
  function clamp01(x) { 
    return Math.max(0, Math.min(1, x)); 
  }
  
  function formatPercent(x) { 
    if (!isFinite(x)) return '–%';
    const pct = 100 * x;
    if (pct < 0.01) return pct.toFixed(4) + '%';
    if (pct < 1) return pct.toFixed(3) + '%';
    if (pct < 10) return pct.toFixed(2) + '%';
    return pct.toFixed(1) + '%';
  }
  
  function sizeCanvas(canvas) { 
    const ratio = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * ratio;
    canvas.height = rect.height * ratio;
    const ctx = canvas.getContext('2d');
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    return ctx;
  }
  
  function clearCanvas(canvas) { 
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    return ctx;
  }

  // Seeded random number generator for reproducible simulations
  function mulberry32(seed) { 
    return function() { 
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // ===== Mathematical Models =====
  
  // Gambler's Ruin probability (analytical solution)
  function computeRuinProbability(p, targetUnits, lossUnits) {
    if (targetUnits <= 0 || lossUnits <= 0) return 0;
    
    // Special case: fair game (p = 0.5)
    if (Math.abs(p - 0.5) < 1e-12) {
      return lossUnits / (targetUnits + lossUnits);
    }
    
    // General case: unfair game
    const q = 1 - p;
    const ratio = q / p;
    const numerator = 1 - Math.pow(ratio, lossUnits);
    const denominator = 1 - Math.pow(ratio, targetUnits + lossUnits);
    return numerator / denominator;
  }

  // ===== Simulation Engines =====
  
  // Fixed bet strategy simulation
  function simulateFixedBets({ p, target, loss, unit, nPaths, maxSteps = 200000, sampleEvery = 10, rng = Math.random }) {
    const targetUnits = Math.max(1, Math.floor(target / unit));
    const lossUnits = Math.max(1, Math.floor(loss / unit));
    const paths = [];
    let successCount = 0;
    const durations = [];
    
    for (let i = 0; i < nPaths; i++) {
      let bankroll = 0;
      let steps = 0;
      const trajectory = [[0, 0]];
      
      while (bankroll > -lossUnits && bankroll < targetUnits && steps < maxSteps) {
        bankroll += rng() < p ? 1 : -1;
        steps++;
        
        if (steps % sampleEvery === 0) {
          trajectory.push([steps, bankroll]);
        }
      }
      
      const finalPosition = Math.max(-lossUnits, Math.min(targetUnits, bankroll));
      trajectory.push([steps, finalPosition]);
      
      if (finalPosition >= targetUnits) {
        successCount++;
      }
      
      paths.push(trajectory);
      durations.push(steps);
    }
    
    return {
      paths,
      successCount,
      probability: successCount / nPaths,
      durations,
      targetUnits,
      lossUnits
    };
  }

  // Martingale strategy simulation
  function simulateMartingale({ p, target, loss, unit, nPaths, maxSteps = 200000, rng = Math.random }) {
    const paths = [];
    let successCount = 0;
    const durations = [];
    
    for (let i = 0; i < nPaths; i++) {
      let bankroll = 0;
      let bet = unit;
      let steps = 0;
      const trajectory = [[0, 0]];
      
      while (bankroll > -loss && bankroll < target && steps < maxSteps) {
        // Calculate maximum affordable bet
        const maxBet = Math.min(
          bet,
          loss + bankroll,  // Can't bet more than we can afford to lose
          target - bankroll  // Don't bet more than needed to reach target
        );
        
        const win = rng() < p;
        bankroll += win ? maxBet : -maxBet;
        steps++;
        
        // Update bet size: reset on win, double on loss
        if (win) {
          bet = unit;
        } else {
          bet = Math.min(bet * 2, target - bankroll, loss + bankroll);
        }
        
        if (steps % 10 === 0) {
          trajectory.push([steps, bankroll]);
        }
      }
      
      const finalPosition = Math.max(-loss, Math.min(target, bankroll));
      trajectory.push([steps, finalPosition]);
      
      if (finalPosition >= target) {
        successCount++;
      }
      
      paths.push(trajectory);
      durations.push(steps);
    }
    
    return {
      paths,
      successCount,
      probability: successCount / nPaths,
      durations
    };
  }

  // ===== Visualization Functions =====
  
  function drawWheelChart() {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const canvas = $('#wheelChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    const centerX = w / 2;
    const centerY = h / 2;
    const radius = Math.min(w, h) / 2 - 20;
    
    // Draw background circle
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.2)';
    ctx.lineWidth = 20;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Draw probability arc
    const gradient = ctx.createLinearGradient(centerX - radius, centerY, centerX + radius, centerY);
    gradient.addColorStop(0, '#6C1AFF');
    gradient.addColorStop(1, '#9D4DFF');
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * p);
    ctx.stroke();
    
    // Draw center text
    ctx.fillStyle = '#F8F1FF';
    ctx.font = 'bold 28px Inter, system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(formatPercent(p), centerX, centerY);
    
    // Draw label
    ctx.font = '14px Inter, system-ui';
    ctx.fillStyle = '#B8B3C8';
    ctx.fillText('Win Probability', centerX, centerY + 30);
  }

  function drawPathsChart(paths, target, loss) {
    const canvas = $('#pathsChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    // Calculate chart dimensions
    const margin = { left: 50, right: 20, top: 20, bottom: 40 };
    const chartWidth = w - margin.left - margin.right;
    const chartHeight = h - margin.top - margin.bottom;
    
    // Find maximum time for x-axis scaling
    let maxTime = 0;
    paths.forEach(path => {
      const lastPoint = path[path.length - 1];
      if (lastPoint[0] > maxTime) maxTime = lastPoint[0];
    });
    
    // Scaling functions
    const xScale = t => margin.left + (t / maxTime) * chartWidth;
    const yScale = y => margin.top + (target - (y + loss)) * (chartHeight / (target + loss));
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw target line (success)
    ctx.strokeStyle = '#6C1AFF';
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(margin.left, yScale(target));
    ctx.lineTo(w - margin.right, yScale(target));
    ctx.stroke();
    
    // Draw ruin line (failure)
    ctx.strokeStyle = '#FF1A4D';
    ctx.beginPath();
    ctx.moveTo(margin.left, yScale(-loss));
    ctx.lineTo(w - margin.right, yScale(-loss));
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Draw paths
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4;
    paths.forEach(path => {
      const lastPoint = path[path.length - 1];
      const success = lastPoint[1] >= target;
      
      // Color based on outcome
      ctx.strokeStyle = success ? '#9D4DFF' : '#FF4D88';
      
      ctx.beginPath();
      path.forEach(([t, y], i) => {
        const x = xScale(t);
        const yPos = yScale(y);
        if (i === 0) {
          ctx.moveTo(x, yPos);
        } else {
          ctx.lineTo(x, yPos);
        }
      });
      ctx.stroke();
    });
    ctx.globalAlpha = 1;
    
    // Draw labels
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '12px Inter, system-ui';
    ctx.fillText('Target (+$' + target + ')', w - margin.right - 100, yScale(target) - 8);
    ctx.fillText('Ruin (−$' + loss + ')', w - margin.right - 100, yScale(-loss) - 8);
    ctx.fillText('Time (steps)', w / 2, h - 10);
    
    // Y-axis label
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Bankroll ($)', 0, 0);
    ctx.restore();
  }

  function drawHistogram(durations) {
    const canvas = $('#histChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    if (durations.length === 0) return;
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    const margin = { left: 50, right: 20, top: 20, bottom: 40 };
    const chartWidth = w - margin.left - margin.right;
    const chartHeight = h - margin.top - margin.bottom;
    
    // Create histogram bins
    const maxDuration = Math.max(...durations);
    const numBins = 30;
    const binWidth = Math.ceil(maxDuration / numBins);
    const histogram = new Array(numBins).fill(0);
    
    durations.forEach(duration => {
      const binIndex = Math.min(numBins - 1, Math.floor(duration / binWidth));
      histogram[binIndex]++;
    });
    
    const maxCount = Math.max(...histogram);
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw bars
    const barGap = 2;
    const actualBarWidth = (chartWidth / numBins) - barGap;
    
    histogram.forEach((count, i) => {
      const x = margin.left + i * (chartWidth / numBins) + barGap / 2;
      const barHeight = (count / maxCount) * chartHeight;
      const y = margin.top + chartHeight - barHeight;
      
      // Create gradient for bars
      const gradient = ctx.createLinearGradient(x, y, x, y + barHeight);
      gradient.addColorStop(0, '#9D4DFF');
      gradient.addColorStop(1, '#6C1AFF');
      ctx.fillStyle = gradient;
      
      ctx.fillRect(x, y, actualBarWidth, barHeight);
    });
    
    // Draw labels
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '12px Inter, system-ui';
    ctx.fillText('Duration (steps)', w / 2, h - 10);
    
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Frequency', 0, 0);
    ctx.restore();
  }

  function drawComparisonChart(target, loss) {
    const canvas = $('#compareChart');
    const ctx = sizeCanvas(canvas);
    clearCanvas(canvas);
    
    const w = canvas.width / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    
    const margin = { left: 50, right: 20, top: 20, bottom: 40 };
    const chartWidth = w - margin.left - margin.right;
    const chartHeight = h - margin.top - margin.bottom;
    
    // Generate probability points from 0.45 to 0.50
    const probabilities = [];
    for (let i = 0; i <= 50; i++) {
      probabilities.push(0.45 + i * 0.05 / 50);
    }
    
    // Calculate success rates for both strategies
    const singleBetProbs = probabilities.map(p => p);
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const targetUnits = Math.max(1, Math.floor(target / unit));
    const lossUnits = Math.max(1, Math.floor(loss / unit));
    const multiBetProbs = probabilities.map(p => computeRuinProbability(p, targetUnits, lossUnits));
    
    // Draw axes
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, h - margin.bottom);
    ctx.lineTo(w - margin.right, h - margin.bottom);
    ctx.stroke();
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(157, 77, 255, 0.1)';
    ctx.setLineDash([2, 4]);
    for (let i = 0; i <= 5; i++) {
      const y = margin.top + (i / 5) * chartHeight;
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(w - margin.right, y);
      ctx.stroke();
    }
    ctx.setLineDash([]);
    
    // Plot functions
    function plotLine(values, color, width = 3) {
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      values.forEach((value, i) => {
        const x = margin.left + (i / (values.length - 1)) * chartWidth;
        const y = margin.top + (1 - value) * chartHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
    }
    
    // Draw the lines
    plotLine(singleBetProbs, '#FF1A4D');
    plotLine(multiBetProbs, '#6C1AFF');
    
    // Draw current probability marker
    const currentP = clamp01(parseFloat(elements.p.value || '0.4737'));
    const currentIndex = Math.round(((currentP - 0.45) / 0.05) * 50);
    if (currentIndex >= 0 && currentIndex < probabilities.length) {
      const x = margin.left + (currentIndex / (probabilities.length - 1)) * chartWidth;
      
      ctx.strokeStyle = '#FCD34D';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(x, margin.top);
      ctx.lineTo(x, h - margin.bottom);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    
    // Draw legend
    ctx.font = 'bold 12px Inter, system-ui';
    
    ctx.fillStyle = '#FF1A4D';
    ctx.fillRect(margin.left + 10, margin.top + 10, 20, 3);
    ctx.fillStyle = '#F8F1FF';
    ctx.fillText('Single Big Bet', margin.left + 35, margin.top + 14);
    
    ctx.fillStyle = '#6C1AFF';
    ctx.fillRect(margin.left + 10, margin.top + 30, 20, 3);
    ctx.fillStyle = '#F8F1FF';
    ctx.fillText('Many Small Bets', margin.left + 35, margin.top + 34);
    
    // Draw axis labels
    ctx.fillStyle = '#B8B3C8';
    ctx.font = '12px Inter, system-ui';
    ctx.fillText('Win Probability (p)', w / 2, h - 10);
    
    ctx.save();
    ctx.translate(15, h / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Success Rate', 0, 0);
    ctx.restore();
  }

  // ===== Wheel Animation =====
  function spinWheel(p) {
    const wheel = elements.wheel;
    const duration = 1500;
    const spins = 5 + Math.random() * 3;
    const finalRotation = spins * 360 + Math.random() * 360;
    
    wheel.animate([
      { transform: 'rotate(0deg)' },
      { transform: `rotate(${finalRotation}deg)` }
    ], {
      duration: duration,
      easing: 'cubic-bezier(0.25, 0.1, 0.25, 1)'
    });
    
    setTimeout(() => {
      const won = Math.random() < p;
      elements.bigOutcome.textContent = won ? 'WIN!' : 'LOSE';
      elements.bigOutcome.className = won ? 'pill success' : 'pill danger';
    }, duration);
  }

  // ===== Live Simulation State =====
  let liveSimulation = {
    active: false,
    state: null,
    animationFrame: null,
    rng: mulberry32(Date.now())
  };

  function resetLiveSimulation() {
    liveSimulation.active = false;
    liveSimulation.state = null;
    if (liveSimulation.animationFrame) {
      cancelAnimationFrame(liveSimulation.animationFrame);
    }
    elements.liveStatus.textContent = 'Ready';
    elements.liveStatus.className = 'pill';
  }

  function startLiveSimulation() {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const target = Math.max(1, parseFloat(elements.target.value || '100'));
    const loss = Math.max(1, parseFloat(elements.loss.value || '10000'));
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const strategy = elements.strategy.value;
    
    liveSimulation.state = {
      p, target, loss, unit, strategy,
      time: 0,
      bankroll: 0,
      bet: unit,
      trajectory: [[0, 0]]
    };
    
    liveSimulation.active = true;
    liveSimulation.rng = mulberry32(Date.now());
    elements.liveStatus.textContent = 'Running';
    elements.liveStatus.className = 'pill success';
    
    animateLiveSimulation();
  }

  function stepLiveSimulation() {
    if (!liveSimulation.state) {
      startLiveSimulation();
      return;
    }
    
    const { p, target, loss, unit, strategy } = liveSimulation.state;
    
    if (strategy === 'unit') {
      // Fixed bet strategy
      const won = liveSimulation.rng() < p;
      liveSimulation.state.bankroll += won ? unit : -unit;
    } else {
      // Martingale strategy
      const maxBet = Math.min(
        liveSimulation.state.bet,
        loss + liveSimulation.state.bankroll,
        target - liveSimulation.state.bankroll
      );
      
      const won = liveSimulation.rng() < p;
      liveSimulation.state.bankroll += won ? maxBet : -maxBet;
      
      if (won) {
        liveSimulation.state.bet = unit;
      } else {
        liveSimulation.state.bet = Math.min(
          liveSimulation.state.bet * 2,
          target - liveSimulation.state.bankroll,
          loss + liveSimulation.state.bankroll
        );
      }
    }
    
    liveSimulation.state.time++;
    
    if (liveSimulation.state.time % 10 === 0) {
      liveSimulation.state.trajectory.push([
        liveSimulation.state.time,
        liveSimulation.state.bankroll
      ]);
    }
    
    // Check for termination
    if (liveSimulation.state.bankroll >= target) {
      liveSimulation.active = false;
      elements.liveStatus.textContent = 'Success!';
      elements.liveStatus.className = 'pill success';
      liveSimulation.state.trajectory.push([
        liveSimulation.state.time,
        target
      ]);
    } else if (liveSimulation.state.bankroll <= -loss) {
      liveSimulation.active = false;
      elements.liveStatus.textContent = 'Ruined';
      elements.liveStatus.className = 'pill danger';
      liveSimulation.state.trajectory.push([
        liveSimulation.state.time,
        -loss
      ]);
    }
    
    // Update visualization
    drawPathsChart([liveSimulation.state.trajectory], target, loss);
  }

  function animateLiveSimulation() {
    if (!liveSimulation.active) return;
    
    const speed = parseInt(elements.speed.value, 10);
    const delay = 1000 / Math.max(1, speed);
    
    setTimeout(() => {
      stepLiveSimulation();
      if (liveSimulation.active) {
        liveSimulation.animationFrame = requestAnimationFrame(animateLiveSimulation);
      }
    }, delay);
  }

  // ===== Main Update Function =====
  function updateSimulation() {
    // Handle preset selection
    if (elements.preset.value === 'american') {
      elements.p.value = (18/38).toFixed(4);
    } else if (elements.preset.value === 'european') {
      elements.p.value = (18/37).toFixed(4);
    }
    
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const target = Math.max(1, parseFloat(elements.target.value || '100'));
    const loss = Math.max(1, parseFloat(elements.loss.value || '10000'));
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const strategy = elements.strategy.value;
    
    // Update single bet display
    elements.bigProb.textContent = formatPercent(p);
    elements.bigBar.style.width = (100 * p).toFixed(2) + '%';
    drawWheelChart();
    
    // Update multi-bet display
    if (strategy === 'unit') {
      const targetUnits = Math.max(1, Math.floor(target / unit));
      const lossUnits = Math.max(1, Math.floor(loss / unit));
      const probability = computeRuinProbability(p, targetUnits, lossUnits);
      
      elements.ruinProb.textContent = formatPercent(probability);
      elements.ruinBar.style.width = (100 * probability).toFixed(2) + '%';
      
      elements.analyticNote.innerHTML = `
        Exact formula: <span class="mono">P = [1 − (q/p)^B] / [1 − (q/p)^(A+B)]</span><br>
        where A = ${targetUnits} units, B = ${lossUnits} units, q = ${(1-p).toFixed(4)}
      `;
    } else {
      elements.ruinProb.textContent = 'Calculating...';
      elements.ruinBar.style.width = '0%';
      elements.analyticNote.innerHTML = `
        Martingale strategy: No closed-form solution. Results from Monte Carlo simulation.
      `;
    }
    
    // Generate sample paths for visualization
    const rng = mulberry32(42);
    let samplePaths;
    
    if (strategy === 'unit') {
      const result = simulateFixedBets({
        p, target, loss, unit,
        nPaths: 25,
        rng
      });
      samplePaths = result.paths.map(path => 
        path.map(([t, y]) => [t, y * unit])
      );
    } else {
      const result = simulateMartingale({
        p, target, loss, unit,
        nPaths: 25,
        rng
      });
      samplePaths = result.paths;
    }
    
    drawPathsChart(samplePaths, target, loss);
    drawComparisonChart(target, loss);
  }

  // ===== Monte Carlo Simulation =====
  function runMonteCarloSimulation() {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    const target = Math.max(1, parseFloat(elements.target.value || '100'));
    const loss = Math.max(1, parseFloat(elements.loss.value || '10000'));
    const unit = Math.max(1, parseFloat(elements.unit.value || '1'));
    const nPaths = Math.max(100, parseInt(elements.paths.value || '5000'));
    const strategy = elements.strategy.value;
    
    elements.runBtn.textContent = 'Simulating...';
    elements.runBtn.disabled = true;
    
    // Run simulation asynchronously
    setTimeout(() => {
      const rng = mulberry32(12345);
      let result;
      
      if (strategy === 'unit') {
        result = simulateFixedBets({
          p, target, loss, unit, nPaths, rng
        });
        
        const targetUnits = result.targetUnits;
        const lossUnits = result.lossUnits;
        const theoretical = computeRuinProbability(p, targetUnits, lossUnits);
        
        elements.ruinProb.innerHTML = `
          ${formatPercent(theoretical)} <span style="font-size: 12px; opacity: 0.8;">(exact)</span><br>
          <span style="font-size: 14px; opacity: 0.7;">
            ${formatPercent(result.probability)} (${nPaths.toLocaleString()} simulations)
          </span>
        `;
        
        // Convert paths back to dollars for display
        const displayPaths = result.paths.slice(0, 50).map(path => 
          path.map(([t, y]) => [t, y * unit])
        );
        drawPathsChart(displayPaths, target, loss);
      } else {
        result = simulateMartingale({
          p, target, loss, unit, nPaths, rng
        });
        
        elements.ruinProb.innerHTML = `
          ${formatPercent(result.probability)}<br>
          <span style="font-size: 14px; opacity: 0.7;">
            (${nPaths.toLocaleString()} simulations)
          </span>
        `;
        
        drawPathsChart(result.paths.slice(0, 50), target, loss);
      }
      
      elements.ruinBar.style.width = (100 * result.probability).toFixed(2) + '%';
      drawHistogram(result.durations);
      
      elements.runBtn.textContent = 'Run Monte Carlo Simulation';
      elements.runBtn.disabled = false;
    }, 100);
  }

  // ===== Verification Tests =====
  function runVerificationTests() {
    elements.selfBtn.disabled = true;
    elements.selfNote.textContent = 'Running tests...';
    elements.selfNote.className = 'pill loading';
    
    setTimeout(() => {
      const tests = [];
      
      // Test 1: Fair game (p = 0.5)
      const fairProb = computeRuinProbability(0.5, 10, 10);
      const fairExpected = 0.5;
      const test1Pass = Math.abs(fairProb - fairExpected) < 1e-10;
      tests.push({
        name: 'Fair Game',
        pass: test1Pass,
        details: `P(0.5, 10, 10) = ${fairProb.toFixed(6)}, expected ${fairExpected}`
      });
      
      // Test 2: Monte Carlo convergence
      const p = 18/38;
      const theoretical = computeRuinProbability(p, 5, 5);
      const mcResult = simulateFixedBets({
        p, target: 5, loss: 5, unit: 1,
        nPaths: 10000,
        rng: mulberry32(77)
      });
      const test2Pass = Math.abs(theoretical - mcResult.probability) < 0.02;
      tests.push({
        name: 'MC Convergence',
        pass: test2Pass,
        details: `Theory: ${theoretical.toFixed(4)}, MC: ${mcResult.probability.toFixed(4)}`
      });
      
      // Test 3: Edge cases
      const edgeCase1 = computeRuinProbability(0, 10, 10);
      const edgeCase2 = computeRuinProbability(1, 10, 10);
      const test3Pass = edgeCase1 === 0 && edgeCase2 === 1;
      tests.push({
        name: 'Edge Cases',
        pass: test3Pass,
        details: `P(0) = ${edgeCase1}, P(1) = ${edgeCase2}`
      });
      
      // Display results
      const allPass = tests.every(t => t.pass);
      
      if (allPass) {
        elements.selfNote.textContent = 'All tests passed!';
        elements.selfNote.className = 'pill success';
      } else {
        const failedTests = tests.filter(t => !t.pass).map(t => t.name).join(', ');
        elements.selfNote.textContent = `Failed: ${failedTests}`;
        elements.selfNote.className = 'pill danger';
      }
      
      // Log details to console
      console.group('Verification Test Results');
      tests.forEach(test => {
        console.log(`${test.pass ? '✅' : '❌'} ${test.name}: ${test.details}`);
      });
      console.groupEnd();
      
      elements.selfBtn.disabled = false;
    }, 500);
  }

  // ===== Event Listeners =====
  elements.preset.addEventListener('change', updateSimulation);
  elements.p.addEventListener('input', updateSimulation);
  elements.target.addEventListener('input', updateSimulation);
  elements.loss.addEventListener('input', updateSimulation);
  elements.unit.addEventListener('input', updateSimulation);
  elements.strategy.addEventListener('change', updateSimulation);
  
  elements.runBtn.addEventListener('click', runMonteCarloSimulation);
  elements.spinBtn.addEventListener('click', () => {
    const p = clamp01(parseFloat(elements.p.value || '0.4737'));
    spinWheel(p);
  });
  
  elements.playBtn.addEventListener('click', () => {
    if (!liveSimulation.active) {
      resetLiveSimulation();
      startLiveSimulation();
    }
  });
  
  elements.pauseBtn.addEventListener('click', () => {
    liveSimulation.active = false;
    elements.liveStatus.textContent = 'Paused';
    elements.liveStatus.className = 'pill warning';
  });
  
  elements.stepBtn.addEventListener('click', () => {
    if (liveSimulation.active) {
      liveSimulation.active = false;
    }
    stepLiveSimulation();
  });
  
  elements.selfBtn.addEventListener('click', runVerificationTests);
  
  // Handle window resize
  window.addEventListener('resize', () => {
    updateSimulation();
  });
  
  // ===== Initialize =====
  updateSimulation();
</script>
</body>
</html>