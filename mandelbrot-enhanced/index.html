<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Enhanced Mandelbrot Explorer - Griffin Rutherford</title>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --dark-bg: #121212;
            --primary-purple: #6C1AFF;
            --primary-red: #FF1A6C;
            --primary-green: #39FF14;
            --primary-blue: #00D4FF;
            --text-color: #FFFFFF;
            --panel-bg: rgba(30, 30, 30, 0.9);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Russo One', sans-serif;
            color: var(--text-color);
            background-color: var(--dark-bg);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            margin: 0;
            padding: 0;
            touch-action: none; /* Prevent default touch behaviors */
        }
        
        #header {
            background: var(--panel-bg);
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid var(--primary-purple);
            position: relative;
            z-index: 100;
        }
        
        h1 {
            font-size: 2rem;
            color: var(--primary-purple);
            text-transform: uppercase;
            letter-spacing: 0.2rem;
            text-shadow: 0 0 20px rgba(108, 26, 255, 0.5);
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 0.9rem;
            color: #999;
            font-family: Arial, sans-serif;
        }
        
        #container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            min-height: 0; /* Fix flexbox issue on mobile */
        }
        
        #canvas {
            flex: 1;
            cursor: grab;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none; /* Important for touch gestures */
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--primary-purple);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 300px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            color: var(--primary-purple);
            margin-bottom: 10px;
            font-size: 1rem;
            text-transform: uppercase;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 4px;
            outline: none;
            margin-bottom: 5px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-purple);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-red);
            box-shadow: 0 0 10px var(--primary-red);
        }
        
        .range-value {
            display: inline-block;
            color: var(--primary-green);
            font-size: 0.9rem;
        }
        
        select {
            width: 100%;
            padding: 8px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            font-family: 'Russo One', sans-serif;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(45deg, var(--primary-purple), var(--primary-red));
            color: white;
            border: none;
            border-radius: 4px;
            font-family: 'Russo One', sans-serif;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 26, 255, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--primary-purple);
            font-size: 0.9rem;
            max-width: 400px;
        }
        
        #info span {
            color: var(--primary-green);
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel-bg);
            padding: 20px 40px;
            border-radius: 8px;
            border: 1px solid var(--primary-purple);
            display: none;
        }
        
        .loading-bar {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-purple), var(--primary-red));
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .home-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: var(--primary-red);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            transition: all 0.3s ease;
            z-index: 101;
        }
        
        .home-button:hover {
            background-color: var(--primary-purple);
            box-shadow: 0 0 15px rgba(108, 26, 255, 0.5);
            transform: scale(1.1);
        }
        
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .theme-btn {
            padding: 8px;
            font-size: 0.8rem;
            margin-bottom: 0;
        }
        
        .coordinates {
            margin-top: 10px;
            padding: 10px;
            background: #222;
            border-radius: 4px;
            font-size: 0.8rem;
            word-break: break-all;
        }
        
        .coordinate-row {
            margin-bottom: 5px;
        }
        
        .coordinate-label {
            color: var(--primary-purple);
            display: inline-block;
            width: 60px;
        }
        
        .coordinate-value {
            color: var(--primary-green);
            font-family: monospace;
        }
        
        /* Performance indicator */
        #performance {
            position: absolute;
            top: 20px;
            left: 80px;
            background: var(--panel-bg);
            padding: 10px 15px;
            border-radius: 4px;
            border: 1px solid var(--primary-green);
            font-size: 0.8rem;
            z-index: 100;
        }
        
        #performance span {
            color: var(--primary-green);
        }
        
        .touch-hint {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(108, 26, 255, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.8rem;
            z-index: 998;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .touch-hint.show {
            opacity: 1;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            #header {
                padding: 0.5rem;
                flex-shrink: 0;
            }
            
            h1 {
                font-size: 1.2rem;
                letter-spacing: 0.1rem;
            }
            
            .subtitle {
                font-size: 0.7rem;
            }
            
            #controls {
                position: fixed;
                bottom: 0;
                right: 0;
                left: 0;
                top: auto;
                max-height: 50vh;
                max-height: 50dvh;
                width: 100%;
                border-radius: 16px 16px 0 0;
                transform: translateY(calc(100% - 50px));
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                padding: 15px;
                padding-top: 25px;
                box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
                z-index: 1000;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            #controls.expanded {
                transform: translateY(0);
            }
            
            #controls::before {
                content: '';
                position: absolute;
                top: 8px;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background: var(--primary-purple);
                border-radius: 2px;
            }
            
            .control-group {
                margin-bottom: 15px;
            }
            
            .control-group h3 {
                font-size: 0.9rem;
                margin-bottom: 8px;
            }
            
            label {
                font-size: 0.8rem;
            }
            
            select, button {
                font-size: 0.8rem;
                padding: 8px;
            }
            
            .theme-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .theme-btn {
                padding: 6px;
                font-size: 0.7rem;
            }
            
            #info {
                display: none;
            }
            
            #performance {
                top: auto;
                bottom: 70px;
                left: 10px;
                font-size: 0.7rem;
                padding: 8px 12px;
                background: rgba(30, 30, 30, 0.8);
                z-index: 999;
            }
            
            .home-button {
                width: 40px;
                height: 40px;
                top: 10px;
                left: 10px;
            }
            
            .home-button svg {
                width: 20px;
                height: 20px;
            }
            
            .coordinates {
                font-size: 0.7rem;
                padding: 8px;
            }
            
            .coordinate-label {
                width: 50px;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 480px) {
            #controls {
                max-height: 60vh;
                max-height: 60dvh;
            }
            
            .theme-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Portrait orientation specific fixes */
        @media (orientation: portrait) {
            #container {
                width: 100vw;
                height: calc(100vh - 80px);
                height: calc(100dvh - 80px);
            }
        }
        
        /* Handle notch/safe areas on modern phones */
        @supports (padding: env(safe-area-inset-bottom)) {
            #controls {
                padding-bottom: calc(15px + env(safe-area-inset-bottom));
            }
        }
    </style>
</head>
<body>
    <!-- Home Button -->
    <a href=".." class="home-button">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 9L12 2L21 9V20C21 20.5304 20.7893 21.0391 20.4142 21.4142C20.0391 21.7893 19.5304 22 19 22H5C4.46957 22 3.96086 21.7893 3.58579 21.4142C3.21071 21.0391 3 20.5304 3 20V9Z" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M9 22V12H15V22" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
    
    <!-- Header -->
    <div id="header">
        <h1>Enhanced Mandelbrot Explorer</h1>
        <div class="subtitle">WebGL-Accelerated Fractal Visualization</div>
    </div>
    
    <!-- Performance Indicator -->
    <div id="performance">
        FPS: <span id="fps">0</span> | Render: <span id="renderTime">0</span>ms
    </div>
    
    <!-- Main Container -->
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <!-- Touch hint for mobile users -->
        <div id="touchHint" class="touch-hint">Use two fingers to zoom</div>
        
        <!-- Controls Panel -->
        <div id="controls">
            <div class="control-group">
                <h3>Visualization</h3>
                <label for="iterations">Max Iterations: <span class="range-value" id="iterationsValue">200</span></label>
                <input type="range" id="iterations" min="50" max="2000" value="200" step="50">
                
                <label for="quality">Render Quality:</label>
                <select id="quality">
                    <option value="0.5">Low (Fast)</option>
                    <option value="1" selected>Normal</option>
                    <option value="2">High (Slow)</option>
                    <option value="4">Ultra (Very Slow)</option>
                </select>
                
                <label for="smoothing">Color Smoothing:</label>
                <select id="smoothing">
                    <option value="none">None</option>
                    <option value="linear" selected>Linear</option>
                    <option value="smooth">Smooth</option>
                    <option value="ultra">Ultra Smooth</option>
                </select>
            </div>
            
            <div class="control-group">
                <h3>Color Themes</h3>
                <div class="theme-grid">
                    <button class="theme-btn" data-theme="classic">Classic</button>
                    <button class="theme-btn" data-theme="fire">Fire</button>
                    <button class="theme-btn" data-theme="ocean">Ocean</button>
                    <button class="theme-btn" data-theme="twilight">Twilight</button>
                    <button class="theme-btn" data-theme="neon">Neon</button>
                    <button class="theme-btn" data-theme="monochrome">Monochrome</button>
                    <button class="theme-btn" data-theme="rainbow">Rainbow</button>
                    <button class="theme-btn" data-theme="cyberpunk">Cyberpunk</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Animation</h3>
                <label for="animateZoom">
                    <input type="checkbox" id="animateZoom"> Animate Zoom
                </label>
                <label for="animateColors">
                    <input type="checkbox" id="animateColors"> Animate Colors
                </label>
                <label for="animSpeed">Animation Speed: <span class="range-value" id="animSpeedValue">1.0</span></label>
                <input type="range" id="animSpeed" min="0.1" max="5" value="1" step="0.1">
            </div>
            
            <div class="control-group">
                <h3>Actions</h3>
                <button id="resetView">Reset View</button>
                <button id="saveImage">Save Image</button>
                <button id="fullscreen">Fullscreen</button>
            </div>
            
            <div class="control-group">
                <h3>Location</h3>
                <div class="coordinates">
                    <div class="coordinate-row">
                        <span class="coordinate-label">Center X:</span>
                        <span class="coordinate-value" id="centerX">-0.5</span>
                    </div>
                    <div class="coordinate-row">
                        <span class="coordinate-label">Center Y:</span>
                        <span class="coordinate-value" id="centerY">0</span>
                    </div>
                    <div class="coordinate-row">
                        <span class="coordinate-label">Zoom:</span>
                        <span class="coordinate-value" id="zoomLevel">1</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Info Panel -->
        <div id="info">
            <strong>Controls:</strong><br>
            • <span>Mouse wheel</span>: Zoom in/out<br>
            • <span>Click & drag</span>: Pan around<br>
            • <span>Double-click</span>: Zoom in<br>
            • <span>Shift + Click</span>: Zoom out<br>
            • <span>Arrow keys</span>: Fine pan
        </div>
        
        <!-- Loading Indicator -->
        <div id="loading">
            <div>Rendering...</div>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>
    </div>
    
    <script>
        // WebGL Mandelbrot Renderer with optimizations
        class MandelbrotRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                
                // Get WebGL context with mobile-friendly settings
                const contextAttributes = {
                    antialias: false,
                    preserveDrawingBuffer: true,
                    powerPreference: 'default', // Don't force high-performance on mobile
                    alpha: false,
                    depth: false,
                    stencil: false,
                    desynchronized: true // Reduces latency
                };
                
                this.gl = canvas.getContext('webgl2', contextAttributes) || 
                         canvas.getContext('webgl', contextAttributes) ||
                         canvas.getContext('experimental-webgl', contextAttributes);
                         
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                // Handle context loss
                this.canvas.addEventListener('webglcontextlost', (e) => {
                    e.preventDefault();
                    this.contextLost = true;
                    console.log('WebGL context lost');
                });
                
                this.canvas.addEventListener('webglcontextrestored', () => {
                    this.contextLost = false;
                    console.log('WebGL context restored');
                    this.initWebGL();
                    this.initShaders();
                    this.initBuffers();
                });
                
                // Mandelbrot parameters
                this.centerX = -0.5;
                this.centerY = 0;
                this.zoom = 1;
                this.maxIterations = 200;
                this.quality = 1;
                this.smoothing = 'linear';
                this.currentTheme = 'classic';
                this.animateZoom = false;
                this.animateColors = false;
                this.animSpeed = 1;
                
                // Mobile optimization
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                               (window.matchMedia && window.matchMedia('(max-width: 768px)').matches);
                this.isPortrait = window.innerHeight > window.innerWidth;
                this.isLowEnd = this.detectLowEndDevice();
                this.adaptiveQuality = true;
                this.lastRenderTime = 0;
                this.targetFPS = this.isMobile ? 30 : 60;
                this.pixelRatio = window.devicePixelRatio || 1;
                
                // Touch gesture handling
                this.touches = new Map();
                this.pinchStartDistance = 0;
                this.pinchStartZoom = 1;
                this.pinchCenterX = 0;
                this.pinchCenterY = 0;
                this.pinchWorldX = 0;
                this.pinchWorldY = 0;
                
                // Touch sensitivity and smoothing
                this.touchSensitivity = 0.5; // Reduce sensitivity for mobile
                this.touchVelocityX = 0;
                this.touchVelocityY = 0;
                this.touchSmoothingFactor = 0.85;
                this.lastTouchTime = 0;
                
                // Animation parameters
                this.time = 0;
                this.zoomAnimation = 0;
                
                // Mouse interaction
                this.isDragging = false;
                this.lastX = 0;
                this.lastY = 0;
                
                // Interaction throttling
                this.isInteracting = false;
                this.interactionTimeout = null;
                this.renderPending = false;
                this.lastFrameTime = 0;
                
                // Performance tracking
                this.frameCount = 0;
                this.lastFpsUpdate = performance.now();
                this.renderStartTime = 0;
                
                // Initialize WebGL
                this.initWebGL();
                this.initShaders();
                this.initBuffers();
                this.setupEventListeners();
                
                // Apply mobile optimizations
                if (this.isMobile) {
                    this.applyMobileOptimizations();
                }
                
                // Start render loop with a small delay on mobile
                if (this.isMobile) {
                    // Show touch hint briefly
                    setTimeout(() => {
                        const hint = document.getElementById('touchHint');
                        if (hint) {
                            hint.classList.add('show');
                            setTimeout(() => hint.classList.remove('show'), 3000);
                        }
                    }, 500);
                    
                    setTimeout(() => this.animate(), 100);
                } else {
                    this.animate();
                }
            }
            
            detectLowEndDevice() {
                // Check for low-end device indicators
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl');
                if (!gl) return true;
                
                // Check max texture size
                const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                
                // Get renderer info
                const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : '';
                
                // Detect low-end GPUs
                const lowEndGPUs = ['Mali-400', 'Adreno 3', 'PowerVR SGX'];
                const isLowEndGPU = lowEndGPUs.some(gpu => renderer.includes(gpu));
                
                return maxTextureSize < 4096 || isLowEndGPU || navigator.hardwareConcurrency <= 2;
            }
            
            applyMobileOptimizations() {
                // More conservative quality settings for mobile
                const baseQuality = this.isLowEnd ? 0.4 : 0.6;
                
                // Set quality based on orientation
                this.quality = this.isPortrait ? baseQuality * 0.9 : baseQuality;
                
                // Reduce max iterations for better performance
                this.maxIterations = this.isLowEnd ? 80 : (this.isPortrait ? 100 : 120);
                
                // Update UI defaults
                document.getElementById('quality').value = this.quality.toString();
                document.getElementById('iterations').value = this.maxIterations.toString();
                document.getElementById('iterationsValue').textContent = this.maxIterations.toString();
                
                // Disable smoothing on low-end devices
                this.smoothing = this.isLowEnd ? 'none' : 'none';
                document.getElementById('smoothing').value = this.smoothing;
                
                // Disable animations on mobile by default
                this.animateZoom = false;
                this.animateColors = false;
                document.getElementById('animateZoom').checked = false;
                document.getElementById('animateColors').checked = false;
                
                // Set canvas CSS for better mobile rendering
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.imageRendering = 'auto'; // Let browser optimize
                
                // Resize canvas
                this.resize();
            }
            
            initWebGL() {
                const gl = this.gl;
                
                // Enable extensions if available
                try {
                    const ext = gl.getExtension('OES_texture_float');
                    const extLinear = gl.getExtension('OES_texture_float_linear');
                    const extPrecision = gl.getExtension('OES_standard_derivatives');
                } catch (e) {
                    console.log('Some WebGL extensions not available');
                }
                
                // Set WebGL state
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.BLEND);
                gl.disable(gl.CULL_FACE);
                gl.disable(gl.SCISSOR_TEST);
                
                // Set viewport
                this.resize();
                
                // Clear color
                gl.clearColor(0, 0, 0, 1);
            }
            
            initShaders() {
                const vertexShaderSource = `
                    attribute vec2 a_position;
                    varying vec2 v_position;
                    
                    void main() {
                        v_position = a_position;
                        gl_Position = vec4(a_position, 0.0, 1.0);
                    }
                `;
                
                const fragmentShaderSource = `
                    #ifdef GL_FRAGMENT_PRECISION_HIGH
                        precision highp float;
                    #else
                        precision mediump float;
                    #endif
                    
                    varying vec2 v_position;
                    
                    uniform vec2 u_resolution;
                    uniform vec2 u_center;
                    uniform float u_zoom;
                    uniform int u_maxIterations;
                    uniform float u_time;
                    uniform int u_theme;
                    uniform int u_smoothing;
                    uniform bool u_animateColors;
                    
                    vec3 hsv2rgb(vec3 c) {
                        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                    }
                    
                    vec3 getThemeColor(float t, int theme, float time) {
                        if (u_animateColors) {
                            t = mod(t + time * 0.1, 1.0);
                        }
                        
                        if (theme == 0) { // Classic
                            return vec3(
                                0.5 + 0.5 * cos(6.28318 * (t + 0.0)),
                                0.5 + 0.5 * cos(6.28318 * (t + 0.333)),
                                0.5 + 0.5 * cos(6.28318 * (t + 0.666))
                            );
                        } else if (theme == 1) { // Fire
                            return vec3(
                                pow(t, 0.5),
                                pow(t, 1.5),
                                pow(t, 3.0)
                            );
                        } else if (theme == 2) { // Ocean
                            return vec3(
                                0.0,
                                0.5 + 0.5 * sin(t * 3.14159),
                                0.5 + 0.5 * cos(t * 3.14159)
                            );
                        } else if (theme == 3) { // Twilight
                            return vec3(
                                0.5 + 0.3 * sin(t * 6.28318),
                                0.3 + 0.3 * sin(t * 6.28318 + 2.0),
                                0.7 + 0.3 * sin(t * 6.28318 + 4.0)
                            );
                        } else if (theme == 4) { // Neon
                            float hue = mod(t * 2.0 + time * 0.1, 1.0);
                            return hsv2rgb(vec3(hue, 1.0, 1.0));
                        } else if (theme == 5) { // Monochrome
                            float v = pow(t, 0.5);
                            return vec3(v, v, v);
                        } else if (theme == 6) { // Rainbow
                            return hsv2rgb(vec3(t, 0.8, 0.9));
                        } else { // Cyberpunk
                            return vec3(
                                1.0 - pow(1.0 - t, 2.0),
                                pow(t, 2.0),
                                abs(sin(t * 10.0))
                            );
                        }
                    }
                    
                    void main() {
                        vec2 coord = v_position * 0.5 + 0.5;
                        coord = coord * u_resolution;
                        
                        // Convert to complex plane coordinates with proper aspect ratio handling
                        float aspectRatio = u_resolution.x / u_resolution.y;
                        vec2 normalizedCoord = coord / u_resolution - 0.5;
                        
                        // Maintain consistent view regardless of screen orientation
                        vec2 c;
                        if (aspectRatio > 1.0) {
                            // Landscape
                            c = u_center + normalizedCoord * vec2(aspectRatio, 1.0) * 4.0 / u_zoom;
                        } else {
                            // Portrait - adjust scaling to maintain view
                            c = u_center + normalizedCoord * vec2(1.0, 1.0 / aspectRatio) * 4.0 / u_zoom;
                        }
                        
                        // Mandelbrot iteration with mobile-friendly loop
                        vec2 z = vec2(0.0);
                        int iter = u_maxIterations;
                        float escapeRadius = 4.0;
                        
                        // Use a fixed upper bound for mobile compatibility
                        const int MAX_ITER = 500;
                        
                        for (int i = 0; i < MAX_ITER; i++) {
                            if (i >= u_maxIterations) {
                                iter = u_maxIterations;
                                break;
                            }
                            
                            float x2 = z.x * z.x;
                            float y2 = z.y * z.y;
                            
                            if (x2 + y2 > escapeRadius) {
                                iter = i;
                                break;
                            }
                            
                            z = vec2(x2 - y2 + c.x, 2.0 * z.x * z.y + c.y);
                        }
                        
                        // Color calculation with explicit alpha
                        if (iter >= u_maxIterations - 1) {
                            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                        } else {
                            float t = float(iter) / float(u_maxIterations);
                            
                            // Apply smoothing
                            if (u_smoothing > 0) {
                                float log_zn = log(z.x * z.x + z.y * z.y) / 2.0;
                                float nu = log(log_zn / log(2.0)) / log(2.0);
                                t = float(iter) + 1.0 - nu;
                                t = t / float(u_maxIterations);
                                
                                if (u_smoothing > 1) {
                                    t = smoothstep(0.0, 1.0, t);
                                }
                                
                                if (u_smoothing > 2) {
                                    t = t * t * (3.0 - 2.0 * t);
                                }
                            }
                            
                            vec3 color = getThemeColor(t, u_theme, u_time);
                            gl_FragColor = vec4(color, 1.0);
                        }
                    }
                `;
                
                // Compile shaders
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                // Create program
                this.program = this.createProgram(vertexShader, fragmentShader);
                
                // Get uniform locations
                this.uniforms = {
                    resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
                    center: this.gl.getUniformLocation(this.program, 'u_center'),
                    zoom: this.gl.getUniformLocation(this.program, 'u_zoom'),
                    maxIterations: this.gl.getUniformLocation(this.program, 'u_maxIterations'),
                    time: this.gl.getUniformLocation(this.program, 'u_time'),
                    theme: this.gl.getUniformLocation(this.program, 'u_theme'),
                    smoothing: this.gl.getUniformLocation(this.program, 'u_smoothing'),
                    animateColors: this.gl.getUniformLocation(this.program, 'u_animateColors')
                };
                
                // Get attribute location
                this.positionAttribute = this.gl.getAttribLocation(this.program, 'a_position');
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                
                return shader;
            }
            
            createProgram(vertexShader, fragmentShader) {
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking error:', this.gl.getProgramInfoLog(program));
                    this.gl.deleteProgram(program);
                    return null;
                }
                
                return program;
            }
            
            initBuffers() {
                // Create a buffer for the square
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                this.positionBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);
            }
            
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
                this.canvas.addEventListener('dblclick', this.handleDoubleClick.bind(this));
                
                // Touch events
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                
                // Keyboard events
                window.addEventListener('keydown', this.handleKeyDown.bind(this));
                
                // Window resize and orientation change
                window.addEventListener('resize', () => {
                    this.resize();
                    if (this.isMobile) {
                        this.applyMobileOptimizations();
                    }
                });
                
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        this.resize();
                        if (this.isMobile) {
                            this.applyMobileOptimizations();
                        }
                    }, 100);
                });
                
                // Control panel events
                document.getElementById('iterations').addEventListener('input', (e) => {
                    this.maxIterations = parseInt(e.target.value);
                    document.getElementById('iterationsValue').textContent = this.maxIterations;
                });
                
                // Add touch sensitivity control for mobile
                if (this.isMobile) {
                    // Create sensitivity control
                    const sensitivityControl = document.createElement('div');
                    sensitivityControl.className = 'control-group';
                    sensitivityControl.innerHTML = `
                        <label for="touchSensitivity">Touch Sensitivity: <span class="range-value" id="touchSensitivityValue">0.5</span></label>
                        <input type="range" id="touchSensitivity" min="0.1" max="1.0" value="0.5" step="0.1">
                    `;
                    
                    // Insert after the first control group
                    const firstControlGroup = document.querySelector('.control-group');
                    firstControlGroup.parentNode.insertBefore(sensitivityControl, firstControlGroup.nextSibling);
                    
                    // Add event listener
                    document.getElementById('touchSensitivity').addEventListener('input', (e) => {
                        this.touchSensitivity = parseFloat(e.target.value);
                        document.getElementById('touchSensitivityValue').textContent = this.touchSensitivity.toFixed(1);
                    });
                }
                
                document.getElementById('quality').addEventListener('change', (e) => {
                    this.quality = parseFloat(e.target.value);
                    this.resize();
                });
                
                document.getElementById('smoothing').addEventListener('change', (e) => {
                    this.smoothing = e.target.value;
                });
                
                // Theme buttons
                document.querySelectorAll('.theme-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.currentTheme = btn.dataset.theme;
                    });
                });
                
                // Animation controls
                document.getElementById('animateZoom').addEventListener('change', (e) => {
                    this.animateZoom = e.target.checked;
                });
                
                document.getElementById('animateColors').addEventListener('change', (e) => {
                    this.animateColors = e.target.checked;
                });
                
                document.getElementById('animSpeed').addEventListener('input', (e) => {
                    this.animSpeed = parseFloat(e.target.value);
                    document.getElementById('animSpeedValue').textContent = this.animSpeed.toFixed(1);
                });
                
                // Action buttons
                document.getElementById('resetView').addEventListener('click', () => {
                    this.centerX = -0.5;
                    this.centerY = 0;
                    this.zoom = 1;
                    this.updateCoordinates();
                });
                
                document.getElementById('saveImage').addEventListener('click', () => {
                    this.saveImage();
                });
                
                document.getElementById('fullscreen').addEventListener('click', () => {
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.documentElement.requestFullscreen();
                    }
                });
                
                // Mobile controls toggle with improved touch handling
                const controls = document.getElementById('controls');
                if (window.innerWidth <= 768 || this.isMobile) {
                    let touchStartY = 0;
                    let isSwiping = false;
                    
                    // Prevent scrolling when controls are expanded
                    controls.addEventListener('touchstart', (e) => {
                        touchStartY = e.touches[0].clientY;
                        isSwiping = false;
                    }, { passive: true });
                    
                    controls.addEventListener('touchmove', (e) => {
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                            return; // Allow normal interaction with form elements
                        }
                        
                        const touchY = e.touches[0].clientY;
                        const diff = touchStartY - touchY;
                        
                        if (Math.abs(diff) > 30 && !isSwiping) {
                            isSwiping = true;
                            if (diff > 0 && !controls.classList.contains('expanded')) {
                                controls.classList.add('expanded');
                                e.preventDefault();
                            } else if (diff < 0 && controls.classList.contains('expanded')) {
                                controls.classList.remove('expanded');
                                e.preventDefault();
                            }
                        }
                    }, { passive: false });
                    
                    // Click on drag handle area
                    controls.addEventListener('click', (e) => {
                        const rect = controls.getBoundingClientRect();
                        if (e.clientY < rect.top + 50) {
                            controls.classList.toggle('expanded');
                        }
                    });
                    
                    // Close controls when clicking outside
                    this.canvas.addEventListener('touchstart', () => {
                        if (controls.classList.contains('expanded')) {
                            controls.classList.remove('expanded');
                        }
                    });
                }
            }
            
            handleMouseDown(e) {
                this.isDragging = true;
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                this.canvas.style.cursor = 'grabbing';
            }
            
            handleMouseMove(e) {
                if (!this.isDragging) return;
                
                const dx = e.clientX - this.lastX;
                const dy = e.clientY - this.lastY;
                
                const scale = 4.0 / (this.zoom * this.canvas.width);
                this.centerX -= dx * scale;
                this.centerY += dy * scale;
                
                this.lastX = e.clientX;
                this.lastY = e.clientY;
                
                this.updateCoordinates();
                this.setInteracting(true);
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.canvas.style.cursor = 'grab';
                this.setInteracting(false);
            }
            
            setInteracting(value) {
                this.isInteracting = value;
                
                // Clear any existing timeout
                if (this.interactionTimeout) {
                    clearTimeout(this.interactionTimeout);
                }
                
                // Set timeout to resume normal rendering
                if (value) {
                    this.interactionTimeout = setTimeout(() => {
                        this.isInteracting = false;
                    }, 100);
                }
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                
                // Reduce zoom speed on mobile for more control
                const baseZoomFactor = this.isMobile ? 0.05 : 0.1;
                const zoomFactor = e.deltaY > 0 ? (1 - baseZoomFactor) : (1 + baseZoomFactor);
                
                // Zoom towards mouse position with proper aspect ratio handling
                const aspectRatio = rect.width / rect.height;
                let worldX, worldY;
                
                if (aspectRatio > 1.0) {
                    // Landscape
                    worldX = this.centerX + (x - 0.5) * aspectRatio * 4.0 / this.zoom;
                    worldY = this.centerY - (y - 0.5) * 4.0 / this.zoom;
                } else {
                    // Portrait
                    worldX = this.centerX + (x - 0.5) * 4.0 / this.zoom;
                    worldY = this.centerY - (y - 0.5) * 4.0 / aspectRatio / this.zoom;
                }
                
                this.zoom *= zoomFactor;
                
                if (aspectRatio > 1.0) {
                    this.centerX = worldX - (x - 0.5) * aspectRatio * 4.0 / this.zoom;
                    this.centerY = worldY + (y - 0.5) * 4.0 / this.zoom;
                } else {
                    this.centerX = worldX - (x - 0.5) * 4.0 / this.zoom;
                    this.centerY = worldY + (y - 0.5) * 4.0 / aspectRatio / this.zoom;
                }
                
                this.updateCoordinates();
            }
            
            handleDoubleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;
                
                const aspectRatio = rect.width / rect.height;
                
                if (aspectRatio > 1.0) {
                    // Landscape
                    this.centerX += (x - 0.5) * aspectRatio * 4.0 / this.zoom;
                    this.centerY -= (y - 0.5) * 4.0 / this.zoom;
                } else {
                    // Portrait
                    this.centerX += (x - 0.5) * 4.0 / this.zoom;
                    this.centerY -= (y - 0.5) * 4.0 / aspectRatio / this.zoom;
                }
                
                this.zoom *= e.shiftKey ? 0.5 : 2;
                
                this.updateCoordinates();
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                // Reset velocities on new touch
                this.touchVelocityX = 0;
                this.touchVelocityY = 0;
                this.lastTouchTime = performance.now();
                
                // Store all touches
                for (let touch of e.touches) {
                    this.touches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY
                    });
                }
                
                if (e.touches.length === 1) {
                    this.isDragging = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    // Start pinch gesture
                    this.isDragging = false;
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    
                    // Calculate initial pinch distance
                    this.pinchStartDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    this.pinchStartZoom = this.zoom;
                    
                    // Store the initial pinch center in screen coordinates
                    this.pinchCenterX = (touch1.clientX + touch2.clientX) / 2;
                    this.pinchCenterY = (touch1.clientY + touch2.clientY) / 2;
                    
                    // Calculate and store the world coordinates at the pinch center
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (this.pinchCenterX - rect.left) / rect.width;
                    const y = (this.pinchCenterY - rect.top) / rect.height;
                    const aspectRatio = rect.width / rect.height;
                    
                    if (aspectRatio > 1.0) {
                        // Landscape
                        this.pinchWorldX = this.centerX + (x - 0.5) * aspectRatio * 4.0 / this.zoom;
                        this.pinchWorldY = this.centerY - (y - 0.5) * 4.0 / this.zoom;
                    } else {
                        // Portrait
                        this.pinchWorldX = this.centerX + (x - 0.5) * 4.0 / this.zoom;
                        this.pinchWorldY = this.centerY - (y - 0.5) * 4.0 / aspectRatio / this.zoom;
                    }
                }
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                const currentTime = performance.now();
                const deltaTime = Math.max(1, currentTime - this.lastTouchTime);
                this.lastTouchTime = currentTime;
                
                // Update touch positions
                for (let touch of e.touches) {
                    this.touches.set(touch.identifier, {
                        x: touch.clientX,
                        y: touch.clientY
                    });
                }
                
                if (e.touches.length === 1 && this.isDragging) {
                    const dx = e.touches[0].clientX - this.lastX;
                    const dy = e.touches[0].clientY - this.lastY;
                    
                    // Apply touch sensitivity scaling
                    const scaledDx = dx * this.touchSensitivity;
                    const scaledDy = dy * this.touchSensitivity;
                    
                    // Calculate velocity for smoothing
                    const velocityX = scaledDx / deltaTime * 16; // Normalize to ~60fps
                    const velocityY = scaledDy / deltaTime * 16;
                    
                    // Apply smoothing to velocity
                    this.touchVelocityX = this.touchVelocityX * this.touchSmoothingFactor + 
                                         velocityX * (1 - this.touchSmoothingFactor);
                    this.touchVelocityY = this.touchVelocityY * this.touchSmoothingFactor + 
                                         velocityY * (1 - this.touchSmoothingFactor);
                    
                    // Use canvas actual dimensions for proper scaling
                    const rect = this.canvas.getBoundingClientRect();
                    const scale = 4.0 / (this.zoom * rect.width);
                    
                    // Apply smoothed movement
                    this.centerX -= this.touchVelocityX * scale * (rect.width / rect.height);
                    this.centerY += this.touchVelocityY * scale;
                    
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    
                    this.updateCoordinates();
                    this.setInteracting(true);
                } else if (e.touches.length === 2) {
                    // Handle pinch zoom
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    const currentDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                    
                    if (this.pinchStartDistance > 0) {
                        const scale = currentDistance / this.pinchStartDistance;
                        
                        // Only update if scale changed significantly (reduces jitter)
                        if (Math.abs(scale - 1.0) > 0.01) {
                            // Apply damping to pinch zoom for more control
                            const dampedScale = 1 + (scale - 1) * 0.3; // Reduced from 0.5 to 0.3 for even more control
                            const newZoom = Math.max(0.1, Math.min(1e10, this.pinchStartZoom * dampedScale));
                            
                            // Only update if zoom actually changed
                            if (Math.abs(newZoom - this.zoom) > 0.001) {
                                this.zoom = newZoom;
                                
                                // Keep the world point under the pinch center fixed
                                const rect = this.canvas.getBoundingClientRect();
                                const x = (this.pinchCenterX - rect.left) / rect.width;
                                const y = (this.pinchCenterY - rect.top) / rect.height;
                                const aspectRatio = rect.width / rect.height;
                                
                                if (aspectRatio > 1.0) {
                                    // Landscape
                                    this.centerX = this.pinchWorldX - (x - 0.5) * aspectRatio * 4.0 / this.zoom;
                                    this.centerY = this.pinchWorldY + (y - 0.5) * 4.0 / this.zoom;
                                } else {
                                    // Portrait
                                    this.centerX = this.pinchWorldX - (x - 0.5) * 4.0 / this.zoom;
                                    this.centerY = this.pinchWorldY + (y - 0.5) * 4.0 / aspectRatio / this.zoom;
                                }
                                
                                this.updateCoordinates();
                            }
                        }
                        
                        this.setInteracting(true);
                    }
                }
            }
            
            handleTouchEnd(e) {
                // Remove ended touches
                for (let touch of e.changedTouches) {
                    this.touches.delete(touch.identifier);
                }
                
                if (e.touches.length === 0) {
                    this.isDragging = false;
                    this.pinchStartDistance = 0;
                    this.setInteracting(false);
                    
                    // Apply inertia scrolling only if we were panning, not zooming
                    if (this.touchVelocityX !== 0 || this.touchVelocityY !== 0) {
                        this.applyTouchInertia();
                    }
                    
                    // Reset velocities and pinch data
                    this.touchVelocityX = 0;
                    this.touchVelocityY = 0;
                    this.pinchCenterX = 0;
                    this.pinchCenterY = 0;
                    this.pinchWorldX = 0;
                    this.pinchWorldY = 0;
                } else if (e.touches.length === 1 && this.pinchStartDistance > 0) {
                    // User lifted one finger from pinch, switch to pan mode
                    this.pinchStartDistance = 0;
                    this.isDragging = true;
                    this.lastX = e.touches[0].clientX;
                    this.lastY = e.touches[0].clientY;
                    // Reset velocities to prevent unwanted movement
                    this.touchVelocityX = 0;
                    this.touchVelocityY = 0;
                }
            }
            
            applyTouchInertia() {
                // Only apply inertia if there's significant velocity
                const minVelocity = 0.5;
                if (Math.abs(this.touchVelocityX) < minVelocity && 
                    Math.abs(this.touchVelocityY) < minVelocity) {
                    return;
                }
                
                const rect = this.canvas.getBoundingClientRect();
                const scale = 4.0 / (this.zoom * rect.width);
                const friction = 0.95;
                
                const animate = () => {
                    // Apply friction
                    this.touchVelocityX *= friction;
                    this.touchVelocityY *= friction;
                    
                    // Apply movement
                    this.centerX -= this.touchVelocityX * scale * (rect.width / rect.height) * 0.016;
                    this.centerY += this.touchVelocityY * scale * 0.016;
                    
                    this.updateCoordinates();
                    
                    // Continue animation if velocity is still significant
                    if (Math.abs(this.touchVelocityX) > minVelocity || 
                        Math.abs(this.touchVelocityY) > minVelocity) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            handleKeyDown(e) {
                const moveAmount = 0.1 / this.zoom;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        this.centerX -= moveAmount;
                        break;
                    case 'ArrowRight':
                        this.centerX += moveAmount;
                        break;
                    case 'ArrowUp':
                        this.centerY += moveAmount;
                        break;
                    case 'ArrowDown':
                        this.centerY -= moveAmount;
                        break;
                    case '+':
                    case '=':
                        this.zoom *= 1.2;
                        break;
                    case '-':
                        this.zoom *= 0.8;
                        break;
                    default:
                        return;
                }
                
                e.preventDefault();
                this.updateCoordinates();
            }
            
            resize() {
                const rect = this.canvas.getBoundingClientRect();
                
                // More conservative DPR handling for mobile
                const dpr = this.isMobile ? 1 : Math.min(this.pixelRatio, 2);
                const effectiveQuality = this.quality * dpr;
                
                // Calculate new dimensions
                const width = Math.floor(rect.width * effectiveQuality);
                const height = Math.floor(rect.height * effectiveQuality);
                
                // More aggressive size limits for mobile
                const maxSize = this.isMobile ? (this.isLowEnd ? 1024 : 1536) : 4096;
                const newWidth = Math.min(width, maxSize);
                const newHeight = Math.min(height, maxSize);
                
                // Only resize if dimensions actually changed
                if (this.canvas.width !== newWidth || this.canvas.height !== newHeight) {
                    this.canvas.width = newWidth;
                    this.canvas.height = newHeight;
                    this.gl.viewport(0, 0, newWidth, newHeight);
                }
                
                // Update orientation flag
                this.isPortrait = window.innerHeight > window.innerWidth;
            }
            
            updateCoordinates() {
                document.getElementById('centerX').textContent = this.centerX.toFixed(15);
                document.getElementById('centerY').textContent = this.centerY.toFixed(15);
                document.getElementById('zoomLevel').textContent = this.zoom.toExponential(3);
            }
            
            getThemeIndex() {
                const themes = {
                    'classic': 0,
                    'fire': 1,
                    'ocean': 2,
                    'twilight': 3,
                    'neon': 4,
                    'monochrome': 5,
                    'rainbow': 6,
                    'cyberpunk': 7
                };
                return themes[this.currentTheme] || 0;
            }
            
            getSmoothingIndex() {
                const smoothing = {
                    'none': 0,
                    'linear': 1,
                    'smooth': 2,
                    'ultra': 3
                };
                return smoothing[this.smoothing] || 0;
            }
            
            render() {
                // Skip render if context is lost
                if (this.contextLost) return;
                
                this.renderStartTime = performance.now();
                
                const gl = this.gl;
                
                try {
                    // Ensure WebGL state is correct
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Clear with explicit color
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Use shader program
                    gl.useProgram(this.program);
                    
                    // Set uniforms
                    gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
                    gl.uniform2f(this.uniforms.center, this.centerX, this.centerY);
                    
                    // Apply zoom animation if enabled
                    let currentZoom = this.zoom;
                    if (this.animateZoom) {
                        this.zoomAnimation += 0.01 * this.animSpeed;
                        currentZoom = this.zoom * (1 + 0.1 * Math.sin(this.zoomAnimation));
                    }
                    
                    gl.uniform1f(this.uniforms.zoom, currentZoom);
                    gl.uniform1i(this.uniforms.maxIterations, this.maxIterations);
                    gl.uniform1f(this.uniforms.time, this.time);
                    gl.uniform1i(this.uniforms.theme, this.getThemeIndex());
                    gl.uniform1i(this.uniforms.smoothing, this.getSmoothingIndex());
                    gl.uniform1i(this.uniforms.animateColors, this.animateColors ? 1 : 0);
                    
                    // Bind position buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                    gl.enableVertexAttribArray(this.positionAttribute);
                    gl.vertexAttribPointer(this.positionAttribute, 2, gl.FLOAT, false, 0, 0);
                    
                    // Draw
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                    
                    // Force WebGL to finish rendering
                    if (this.isMobile) {
                        gl.finish();
                    }
                    
                    // Update performance metrics
                    this.updatePerformance();
                } catch (e) {
                    console.error('Render error:', e);
                }
            }
            
            updatePerformance() {
                const renderTime = performance.now() - this.renderStartTime;
                document.getElementById('renderTime').textContent = renderTime.toFixed(1);
                
                this.frameCount++;
                const now = performance.now();
                const elapsed = now - this.lastFpsUpdate;
                
                if (elapsed >= 1000) {
                    const fps = (this.frameCount * 1000) / elapsed;
                    document.getElementById('fps').textContent = fps.toFixed(0);
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
            }
            
            animate() {
                // Use a more stable animation loop
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastFrameTime;
                
                // Target frame time (16.67ms for 60fps, 33.33ms for 30fps)
                const targetFrameTime = 1000 / this.targetFPS;
                
                // Only render if enough time has passed or if we're not on mobile
                if (!this.isMobile || deltaTime >= targetFrameTime * 0.9) {
                    this.lastFrameTime = currentTime;
                    this.time += (deltaTime / 1000) * this.animSpeed;
                    
                    // Skip adaptive quality during interactions to prevent flickering
                    if (!this.isInteracting && this.adaptiveQuality && this.isMobile) {
                        this.adjustQualityBasedOnPerformance();
                    }
                    
                    this.render();
                }
                
                requestAnimationFrame(() => this.animate());
            }
            
            adjustQualityBasedOnPerformance() {
                const renderTime = performance.now() - this.renderStartTime;
                const targetFrameTime = 1000 / this.targetFPS;
                
                // Only adjust every 60 frames to avoid constant changes
                if (this.frameCount % 60 === 0) {
                    const maxQuality = this.isPortrait ? 0.6 : 0.8;
                    const minQuality = this.isLowEnd ? 0.3 : 0.4;
                    
                    // More conservative quality adjustments
                    if (renderTime > targetFrameTime * 1.5 && this.quality > minQuality) {
                        // Reduce quality if performance is poor
                        this.quality = Math.max(minQuality, this.quality * 0.9);
                        this.resize();
                    } else if (renderTime < targetFrameTime * 0.3 && this.quality < maxQuality) {
                        // Increase quality if performance is good
                        this.quality = Math.min(maxQuality, this.quality * 1.05);
                        this.resize();
                    }
                }
            }
            
            saveImage() {
                const link = document.createElement('a');
                link.download = `mandelbrot_${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }
        }
        
        // Initialize renderer when page loads
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            try {
                const renderer = new MandelbrotRenderer(canvas);
                console.log('Mandelbrot renderer initialized');
            } catch (error) {
                console.error('Failed to initialize renderer:', error);
                alert('WebGL is not supported in your browser. Please try a modern browser.');
            }
        });
    </script>
</body>
</html>